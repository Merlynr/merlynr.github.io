<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>吾辈之人，自当自强不息！</title>
  
  <subtitle>博客</subtitle>
  <link href="https://merlynr.github.io/atom.xml" rel="self"/>
  
  <link href="https://merlynr.github.io/"/>
  <updated>2021-06-01T16:00:00.000Z</updated>
  <id>https://merlynr.github.io/</id>
  
  <author>
    <name>Merlynr</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>555~四级</title>
    <link href="https://merlynr.github.io/2021/06/01/555~%E5%9B%9B%E7%BA%A7/"/>
    <id>https://merlynr.github.io/2021/06/01/555~%E5%9B%9B%E7%BA%A7/</id>
    <published>2021-05-31T16:00:00.000Z</published>
    <updated>2021-06-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><p><img src="https://gitee.com/merlynr/img-store/raw/master/202161/1622551964785.png" alt="作文要求"></p><ol><li>时间很紧，第一遍就需要写在纸上</li><li>手写，需要注意字体，建议衡水体</li><li>写的时候右侧也对齐，同时写85%，这样美观</li><li>背一些句型和一些常用词汇的替换词</li><li>切记不要跑题，介意通过直接更改题干来立题</li></ol><p><img src="https://gitee.com/merlynr/img-store/raw/master/202161/1622552071072.png" alt="衡水体"></p><h3 id="衔接词"><a href="#衔接词" class="headerlink" title="衔接词"></a>衔接词</h3><p>due to 因为<br>in spite of尽管，<br>thus因此，<br>on the contrary相反地<br>首先 in the first place, to begin with, first of all, for one thing<br>然后，而且 in addition, what’s more,moreover, besides, for another thing<br>最后 last but not the least<br>表举例 for instance<br>表对比 in contrast, on the contrary</p><h3 id="专业词汇"><a href="#专业词汇" class="headerlink" title="专业词汇"></a>专业词汇</h3><p><a href="https://www.bilibili.com/video/BV1MN411Z7Lu?spm_id_from=333.788.b_765f64657363.3">热点词</a></p><h3 id="例句"><a href="#例句" class="headerlink" title="例句"></a>例句</h3><ol><li>It is obvious that the cartoon is trying to tell us…</li><li>Currently, there is a growing tendency that people in mounting numbers are showing great enthusiasm for sth.</li><li>From my perspective/As for me, at no time should we ignore the importance of A.</li><li>“<strong><strong><strong>” is the opinion held by</strong></strong></strong> . This remark has been confirmed time and again by more and more people. “______”是______的观点，而且被越来越多的人反复证实。</li><li>The advantages of A are much greater than those of B.</li><li>A number of factors are accountable for this situation. 造成这种情况的因素有很多。</li></ol><h2 id="听力"><a href="#听力" class="headerlink" title="听力"></a>听力</h2><ol><li>利用一切时间，读题，找关键词</li><li>可以去预判一些常考的考点【因果、并列、转折、举例、男女对话即为换题的标志】</li><li>一般事请都会有波折，即往不好的方向发展</li><li>当没听清时，往主旨上蒙，越是详细越可能出错</li></ol><h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><p><font color="#00CED1">20mins</font></p><ol><li>原句<font color="#FF1493">重复出现，200%错</font>。正确的都是有改动的，即同意替换。</li><li>文章是<font color="#9400D3">按顺序出题</font>的。你要觉得不是，就是你做错了。</li><li>选项中意思完全相反的2个选项，<font color="#E9967A">其中之一是对的</font>。（要有这个意识）。</li><li>就一般而言，some people，表作者不认同的观点。<font color="#006400">few people，表作者的观点</font>。</li><li>用文章里<font color="#9400D3">举例的句子来作为选项</font>，直接排除。200%错。（要有能辨别这个选项是不是文章中例子的能力）。</li><li>某某人说的话，或者是带引号的，一定要高度<font color="#8B008B">重视</font>。尤其是在段落的后半部分。很有可能就是某个问题的同意替换。即题眼。</li><li>有的时候，一句话可以设2个问题。不过这种情况很少出现了，非常少。。</li><li>文章基本以5段为主（也有6段、7段的），要把握每段之间的关系。一般来说，一段一个题，只是一般来说喔。。</li><li>一篇文章总会有5、6+个长难句，且总会在这里设问题。所以，<font color="#FF8C00">长难句必须要拿下</font>！！</li><li><font color="#9932CC">每段的第一句很重要</font>。尤其总分结构的段。有的时候第一句话就是题眼。考研英语，总分结构或者总分总的段落很多。。</li><li>若文章首段以why为开头的，这里若设题的话，选项里有because的，往往就是正确选项。不过这种类型的题，很少见了。。</li><li>有时候每段的第一句话，仅仅是一个表述。而在第2或3句以后，会出现对比或者转折。一般来说，<font color="#00FFFF">转折后面的是作者的态度</font>。你要注意的是，作者对什么进行了转折。那个关键词你要找出来。</li><li>在应该出现答案的地方，没有答案。。接着往下读。答案可能会在下一段的开头部分。因为文章都是接着说的。要有连贯性。这和7选5的技巧有些相似。不过这种情况并不多见。。</li><li>一个长句看不懂，接着往下看，下一句可能是这个长句的解释说明。是的话，这的地方可能会出题。出的话，答案就在这附近。而实际情况是，文章在谈论某个问题或提出某个观点时，有时会再做进一步的解释说明。这种情况下，这里往往会设问题。不过，这种情况很少见了。。</li><li>有些句子仅仅是解释补充，或者是起过渡作用的。这样句子的特点是，句子比较短。注意，答案一般不会在这儿出现。选项中出现，肯定是<font color="#9932CC">干扰项</font>。你要知道的是，同意替换的句子，大都是长难句。一些作为过渡的句子，不可能是答案。在你读不懂的情况下，要有这个判断力。</li><li>正确选项都是原文中的个别几个词的<font color="#D2691E">同义替换</font>。阅读理解历年的所有真题，都是同意替换！！就看你能不能找得到。考研英语，考的就是这个！！那个关键词，就看你找没找得到，不管是什么类型的题。。</li><li>每一个问题，在原文中，都要有一个定位。然后精读，找出那个中心句或者关键词。要抓文章的中心主旨和各段落的大意，阅读理解考的就是这个“<font color="#057748">中心句</font>”。</li><li>选项中的几个单词，是该段中不同句子里的单词拼凑的，有时看上去很舒服，注意，干扰项。还有从不同的段落里的词拼凑到一起的，直接排除。总之，选项的单词是<font color="#A52A2A">拼凑的</font>，肯定错。</li><li>一定要注意文章中句子的宾语部分，尤其是长难句中主干的宾语。上面说了，考研英语大都是长难句里设题。你要知道的是，长难句里，最可能是出题的就是句子的主干部分！主干的主语、宾语是什么，一定要知道。<font color="#FF1493">正确选项</font>的题眼往往就在这儿。当然，还有一些起修饰、限定作用的词，一定要看仔细。小心陷阱。</li><li>若某个问题，是特别长的一个句子，一定要看清问的是什么，别打马虎眼。这是做题时需要留意的地方。</li><li>注意问题的主语是谁，它和原文题眼的主语原则上是一致的。主语不一致，一般来说，都是<font color="#9400D3">错的。</font></li><li>即第6条，某某人说的话，尤其特别长的句子，或者是带引号的。60%以上会出题。题眼就在这儿。这里又提了一遍，就是要引起你的<font color="#057748">重视</font>。</li><li>错误的选项，往往是就文章某一方面而说的，其特点是：所涉及的，仅仅是某一个小问题，或者很具体，<font color="#B22222">非常具体的一件实事</font>。200%错误选项。这是考研英语最经常遇到的干扰项。一定要会识别。</li><li>中国人出的题。多是总-分结构，或者总-分-总。所以每段开头结尾，都要注意。（这里指的是中间没有出现转折的段落）。整篇文章的<font color="#057748">开头结尾</font>。也要重视。</li><li>文章的结构，要么总-分或总-分-总，要么转折、对比，要么举例说明。就这么几个套路。</li><li>对选项中的“重点词”（即主语、宾语、修饰语）都要看清楚。有的时候，选项中，会对原文中本来正确的事做错误的修改，来作为干扰项。你要注意的是，选项句子的主语（与原文）是否一致、宾语是否符合原文意思，或者用一些牵强的修饰词，来做一些特殊的限定。要看清楚。这是干扰项的特点之一。</li><li>某人说过的话，有时并不是题眼，但可以从侧面或某个角度来反映作者的观点，也就是作者想表达的。<font color="#00FFFF">正确答案都是和这样的观点相一致的</font>。要把握关键词，有感情色彩的词。做题时，要有这个意识。</li><li>就某个词或者某个句子设问题，不用猜词。<font color="#057748">就一条，文章主旨</font>！ 不用去研究这个词什么意思，把握主旨即可。全文主旨和段落主旨（前者更重要）。</li><li>接着28条说，不管什么题型，上面说的还是其他别的题型。很绝对的说，反映主旨的肯定对，前提是你能确定它就是主旨。考研英语，一直到2011年，这一条还没变过。所以，文章读不太懂，但能把握作者想表达的意思即可。如2011年争议题37题。</li><li>注意中心句（即题眼）和前后句子之间的关系，是接着说的，还是转折关系。这里出题的话，要把握和<font color="#8A2BE2">前后句子之间的关系</font>。是并列关系的，可以从这些句子里找同义词。是转折关系的，就通过转折关系句子里的关键词的相反意思来判断。前提是在你读不懂的情况下。</li><li>凡是举例的，都是为了说明观点的。那么，这个观点（中心句），一般来说，会在举例之前就表达了。但有时候也在举例之后。总之，<font color="#bf242a">作者举例想说明的这个观点，你一定要找出来</font>。</li><li>排除2个选项以后，选出和文章主旨相关的选项即可。不知道主旨就把握关键词。</li><li>词汇题的正确答案，往往隐藏在原文的该处附近（就是那个<font color="#0000FF">同义替换词</font>），原文这附近的句子，是并列关系或者解释说明句的，就从这些句子的关键词的相近意思去把握。是转折关系的，就从关键词的相反意思去把握。总之，你要找的就是那个关键词。和30条一起理解吧。。</li><li>如果原文中出现“ A is B and C”。若某一问题，选项中出现了B没C，或者只出现C没B。<font color="#A52A2A">肯定错</font>，直接排除。可能你会问了，同时出现B and C 咋办？ 目前还没出现过这种情况。。注意，这里说的B和C，是单词或者短语。。这是干扰项的特点之一。 实际情况是，这个<font color="#B22222">句子不是题眼</font>。</li><li>接34题说，还一种情况是，若B和C是2个长句子，中间用分号隔开的。且这两个句子都是作者想表达的，选项中都出现了。。一般来说，选项中会对其中之一做错误的修改来作为干扰项。而另一个是对的。（如05年TEXT1 ，第一题。不过总体来说，这种题型非常非常少见。偶在这里想说的是34条。这样的干扰项，你要会识别。）</li><li>注意几个词，yet表转折，hardly表否定。while 有时是比较，有时也表转折。比较的时候，注意比较的对象，要弄清楚。转折的时候，你<font color="#0000FF">要知道作者对什么进行了转折</font>。</li><li>如果你对“关键词”比较蒙，或者你想问：我怎么知道哪个是关键词？解释一下，关键词就是句子中主干的宾语。尤其是一些你觉得比较重要的句子。这样的句子多数是长难句。一般来说，一个句子主干的主语，宾语，和其他的修饰部分，都是很重要的！！ 宾语是主语的宾语，所以，和主语是要对上号的，对不上不行。（也就是26条的主语是否一致）。至于修饰的部分，干扰项常常在这里做手脚，比如会有一些特殊的限定，千万要留意，别疏忽了。。</li><li>什么是中心句？即反应文章的主旨和每一段的中心意思的一句话。这句话是客观存在的。也就是作者的观点。中心句即题眼，选出正确答案，看的就是中心句。只有中心句才能选出正确答案。所以，中心句不知道在哪，或者读不懂，很难选出正确答案。中心句的具体位置，见下条。</li><li><font color="#7FFF00">很关键的一条</font>，抓住每段的中心意思，也就是中心句。每段至少一句，最多2句。 一般来说，总分结构的段落，中心句一般在段首。举例段一般在举例前后。转折段，中心句在出现转折的地方，或者后一句（一般来说在该段的第三行上下浮动）。再就是某某人说的话。要注意这句话和前后句的关系，是并列还是转折。然后来把握这句话的意思，把握不了就通过前后句是并列还是转折关系的关键词来把握。</li><li>每个问题，要还原到文章具体的某一段落。若此问题在某段的后半部分，且你没有太看懂，这段已经完事了。。要养成一个习惯。<font color="#1E90FF">接着看一下段的第一句话</font>。实在做不出来的话，就选那个和下一段第一句话的意思差不多的选项。只能这样了。。 （貌似是13条的重复）补充下，这只是小技巧，只起补充作用，有时候用不上。。</li><li>每段的第三行，一般来说，也是该段的第3句话（也可能是第2、4句话）。其特点是：句子很长，由两句或者两句以上组成，是个长难句。尤其是 that mean ，the notion is that 之类的，一定要重视。要把握句子的主干。作者想说的是什么（把握作者强调的是哪个句子）。看清楚哪句话是为了修饰哪句话的。这样的句子，若出题的话，句子的主干就是正确选项。起补充修饰作用的一定要看清楚。。每段最重要的三个地方：<font color="#0000FF">段首，段尾，和这儿</font>。再就是带引号的。中心句一般就在这几个地方。 其实也就这么几个地方。。别的地方一般都是过渡句。。</li><li>若是转折段的话，要注意转折的那个句子，一般都是在<font color="#0000FF">41条</font>的那个地方（即第三行上下浮动）。转折前后都要看，看对比的是什么。在看不懂的情况下，通过前面的，来翻译后面的（<font color="#00FFFF">反向翻译</font>），来找关键词。反之亦然。</li><li>最后一段，主要看段首和段尾。（最后一段是转折段的情况很少）。若是叙事段的话，叙事部分以外的，重点看。叙事部分尽量看懂。<font color="#725e82">非叙事部分非常重要</font>。一般段首若出现答案的话，段尾可能会作干扰项（见54条），但也不是绝对的（有时段首段尾都会有答案的提示）。段尾若出现答案的话，段首可能会很普通。 一定要把握哪一句话是重点，选项中有相近意思的不是片面的叙述，一般就是正确答案。要把握重点的句子提到的被说明对象（句子主干的宾语），也就是作者关注的。</li><li>选项中出现<font color="#7FFF00">ONLY </font>的，目前还没有对的。</li><li>说明原因的，且<font color="#057748">仅仅是说明原因</font>而已。目前没有对的。</li><li>中心句特别长的，2小句组成，选项中这2句都出现了，怎么排除？反映主旨的是对的。就是作者关注的对象！还一选项是对其进行具体的解释说明，或者补充，或是对主旨的一个具体现象的反应，或是对其造成的后果的叙述。这一选项一般会做错误的修改而作为<font color="#A52A2A">干扰项</font>（即使不做错误的修改也一样是干扰项）总之，这样的题，符合<font color="#1E90FF">28、29</font>条的就是对的。符合<font color="#B22222">23</font>条的，就是错的。</li><li>一定要注意，谁是用来修饰谁的。<font color="#B22222">起修饰作用</font>的词或句子，来做选项，一般是错的。<font color="#057748">被修饰的那部分</font>来作选项，一般是对的。</li><li>因果关系的题，很直接、很简单的因果关系，直接排除。间接的因果，反映主旨的，可能是对的。 总之，因果关系的题，把握主旨就可以了。文中提到的直接因果，如具体的事或是什么的。<font color="#8B0000">都是干扰项</font>。</li><li>48的补充，正确选项反应的，往往是实质的，根本的内容。选项反应的若是<font color="#bf242a">很具体</font>的某一表现，一般都是干扰项。</li><li>干扰项有时出现的生词（可能是你不认识的），是与文章主题无关的词，而非同意替换。（这就需要你的基本功了）</li><li>新趋势，有些题要懂文章才能做出来。读不懂很难选出来。而且，长难句明显增多。有时，它会让你崩溃到单词都认识，却不知道文章说的是什么。这时候什么技巧都不好使了。所以，一定要提高基本功。起码你要知道文章大概说的是啥，也就是谁和谁的关系。任何一篇文章的主旨，基本上都可以用“谁和谁的关系”来概括。</li><li>、通过首段或者前两段，来把握信息点。也就是作者想说的，<font color="#008B8B">是谁和谁的关系</font>？</li><li>接着上面说，一篇文章谈的是什么，或者说“谁与谁的关系”，一定要弄懂。这个具体的什么“关系”弄不懂的话，“谁与谁”一定要弄明白。比如，<font color="#00008B">一篇文章说的是A与B之间如何如何。若问题问你A，选项有B的，往往就是正确答案。若问你B，你就可以先把没有A的选项排除</font>。</li><li>最新趋势，最后一段，段尾很明显不是总结，而是以补充为主的句子。注意，这里可能会<font color="#FF1493">以干扰项的形式出现。</font></li><li>如上所说，中心句出现的地方无非就是段首、段中、段尾，或者带引号的句子。但是，这也是干扰项常常出现的地方。所以，你的基本功，对文章理解的程度，是你必须具备的能力。任何一门考试都有技巧，但是想拿理想的分数，光靠技巧是不现实的。</li><li>有的时候，你会遇到出现2到3个否定词的句子。否定再否定，或者否定否定再否定。遇到了，尤其是3重否定的，基本上<font color="#00008B">这里会设题</font>，这句话里的关键词一定要找出来。这个地方是要练的，到时候出现了，别蒙，别犯怵。。</li><li>再补充一条，<font color="#00008B">however 后面的句子一定要重视</font>。比如有一年的其中一篇的3个题，题眼都是however 后面的句子。 所以，这个词一定要敏感。</li></ol><p><strong><font color="#FF8C00">技巧done</font></strong></p><h2 id="段落匹配"><a href="#段落匹配" class="headerlink" title="段落匹配"></a>段落匹配</h2><p><font color="#9400D3">10mins</font></p><ol><li>看选项，勾关键词【能看懂的】<font color="#FF8C00">3~4mins</font></li><li>找对应的两个及以上的关键词</li></ol><p><strong><font color="#FF8C00">技巧done</font></strong></p><h2 id="选词填空"><a href="#选词填空" class="headerlink" title="选词填空"></a>选词填空</h2><p><font color="#9400D3">10mins</font></p><ol><li>先标词性在选词 </li></ol><h2 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h2><ol><li>替换+尬写</li><li>看一下<a href="https://www.bilibili.com/video/BV1MN411Z7Lu?spm_id_from=333.788.b_765f64657363.3">热点词</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;写作&quot;&gt;&lt;a href=&quot;#写作&quot; class=&quot;headerlink&quot; title=&quot;写作&quot;&gt;&lt;/a&gt;写作&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/merlynr/img-store/raw/master/202161/162255</summary>
      
    
    
    
    <category term="exam" scheme="https://merlynr.github.io/categories/exam/"/>
    
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
    <category term="exam" scheme="https://merlynr.github.io/tags/exam/"/>
    
  </entry>
  
  <entry>
    <title>孤立森林（Isolation Forest）</title>
    <link href="https://merlynr.github.io/2021/05/31/%E5%AD%A4%E7%AB%8B%E6%A3%AE%E6%9E%97%EF%BC%88Isolation%20Forest%EF%BC%89/"/>
    <id>https://merlynr.github.io/2021/05/31/%E5%AD%A4%E7%AB%8B%E6%A3%AE%E6%9E%97%EF%BC%88Isolation%20Forest%EF%BC%89/</id>
    <published>2021-05-30T16:00:00.000Z</published>
    <updated>2021-05-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021531/1622426214147.png" alt="数据蛋糕"></p><p>假设我们用一个随机超平面来切割（split）数据空间（data space）, 切一次可以生成两个子空间（想象拿刀切蛋糕一分为二）。</p><p>之后我们再继续用一个随机超平面来切割每个子空间，循环下去，直到每子空间里面只有一个数据点为止。</p><blockquote><p><font color="#8B008B">满足的条件</font></p><ul><li>数据本身不可再分割</li><li>二叉树达到限定的最大深度</li></ul></blockquote><p>直观上来讲，我们可以发现那些密度很高的簇是可以被切很多次才会停止切割，但是那些密度很低的点很容易很早的就停到一个子空间里了。</p><p><font color="#6495ED">异常检测原理的理解：</font>由于异常值的数量较少且与大部分样本的疏离性，因此，异常值会被更早的孤立出来，也即异常值会距离iTree的根节点更近，而正常值则会距离根节点有更远的距离。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>孤立森林算法主要针对的是<strong>连续型结构化</strong>数据中的异常点。</p><p><font color="#FF1493">理论前提</font></p><ul><li>异常数据占总样本量的比例很小</li><li>异常点的特征值与正常点的差异很大</li></ul><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021531/1622426925434.png" alt="数据"></p><p>上图中，中心的白色空心点为正常点，即处于高密度群体中。四周的黑色实心点为异常点，散落在高密度区域以外的空间。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>孤立森林算法是基于 <strong>Ensemble</strong> 的异常检测方法，因此具有<font color="#7FFF00">线性的时间复杂度</font>。且精准度较高，在处理大数据时速度快，所以目前在工业界的应用范围比较广。常见的场景包括：网络安全中的攻击检测、金融交易欺诈检测、疾病侦测、噪声数据过滤（数据清洗）等。</p><blockquote><p><font color="#006400">知识补充</font>集成学习算法 (Ensemble Learning)<br>统机器学习算法 (例如：决策树，人工神经网络，支持向量机，朴素贝叶斯等) 的目标都是寻找一个最优分类器尽可能的将训练数据分开。集成学习 (Ensemble Learning) 算法的基本思想就是将多个分类器<font color="#8FBC8F">组合</font>，从而实现一个预测效果更好的<font color="#8A2BE2">集成分类器</font>。</p></blockquote><blockquote><p><font color="#FF00FF">知识补充：</font><br><a href="https://blog.zuishuailcq.xyz/2021/05/31/%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/">算法的性能指标 | 吾辈之人，自当自强不息！</a></p></blockquote><h2 id="孤立森林的创新点"><a href="#孤立森林的创新点" class="headerlink" title="孤立森林的创新点"></a>孤立森林的创新点</h2><ol><li><font color="#D2691E">Partial models</font>：在训练过程中，每棵孤立树都是随机选取部分样本</li><li><font color="#D2691E">No distance or density measures</font>：不同于 KMeans、DBSCAN 等算法，孤立森林不需要计算有关距离、密度的指标，可大幅度提升速度，减小系统开销</li><li><font color="#D2691E"> Linear time complexity</font>：因为基于 ensemble，所以有线性时间复杂度。通常树的数量越多，算法越稳定</li><li><font color="#D2691E">Handle extremely large data size</font>：由于每棵树都是独立生成的，因此可部署在大规模分布式系统上来加速运算</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;理解&quot;&gt;&lt;a href=&quot;#理解&quot; class=&quot;headerlink&quot; title=&quot;理解&quot;&gt;&lt;/a&gt;理解&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/merlynr/img-store/raw/master/2021531/16224</summary>
      
    
    
    
    <category term="algorithm" scheme="https://merlynr.github.io/categories/algorithm/"/>
    
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="machine learning" scheme="https://merlynr.github.io/tags/machine-learning/"/>
    
    <category term="algorithm" scheme="https://merlynr.github.io/tags/algorithm/"/>
    
    <category term="data mining" scheme="https://merlynr.github.io/tags/data-mining/"/>
    
  </entry>
  
  <entry>
    <title>拟合</title>
    <link href="https://merlynr.github.io/2021/05/31/%E6%8B%9F%E5%90%88/"/>
    <id>https://merlynr.github.io/2021/05/31/%E6%8B%9F%E5%90%88/</id>
    <published>2021-05-30T16:00:00.000Z</published>
    <updated>2021-06-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/72038532#:~:text=%E5%AF%B9%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%88%96%E6%9C%BA%E5%99%A8,%E7%A7%B0%E4%B8%BA%E6%B3%9B%E5%8C%96%E8%AF%AF%E5%B7%AE%E3%80%82">欠拟合、过拟合及如何防止过拟合 - 知乎</a></p><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>对于深度学习或机器学习模型而言，我们不仅要求它对训练数据集有很好的拟合（训练误差），同时也希望它可以对未知数据集（测试集）有很好的拟合结果（泛化能力），所产生的测试误差被称为泛化误差。度量泛化能力的好坏，最直观的表现就是模型的过拟合（overfitting）和欠拟合（underfitting）。过拟合和欠拟合是用于描述模型在训练过程中的两种状态。一般来说，训练过程会是如下所示的一个曲线图。</p><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021531/1622461280602.png" alt="训练过程"></p><p>训练刚开始的时候，模型还在学习过程中，处于欠拟合区域。随着训练的进行，训练误差和测试误差都下降。在到达一个临界点之后，训练集的误差下降，测试集的误差上升了，这个时候就进入了过拟合区域——由于训练出来的网络过度拟合了训练集，对训练集以外的数据却不有效。</p><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021531/1622461630220.png" alt="拟合"></p><h2 id="欠拟合"><a href="#欠拟合" class="headerlink" title="欠拟合"></a>欠拟合</h2><p><font color="#9932CC">欠拟合</font>是指模型不能在训练集上获得足够低的误差。换句换说，就是模型复杂度低，模型在训练集上就表现很差，没法学习到数据背后的规律。</p><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021531/1622461604985.png" alt="欠拟合"></p><p><strong>如何解决欠拟合？</strong></p><p>欠拟合基本上都会发生在训练刚开始的时候，经过不断训练之后欠拟合应该不怎么考虑了。但是如果真的还是存在的话，可以通过<font color="#7FFF00">增加网络复杂度</font>或者在模型中<font color="#7FFF00">增加特征</font>，这些都是很好解决欠拟合的方法。</p><h2 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h2><p><font color="#9932CC">过拟合</font>是指训练误差和测试误差之间的差距太大。换句换说，就是模型复杂度高于实际问题，<font color="#ff7500">模型在训练集上表现很好，但在测试集上却表现很差。</font>模型对训练集”死记硬背”（记住了不适用于测试集的训练集性质或特点），没有理解数据背后的规律，泛化能力差。</p><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021531/1622461615228.png" alt="过拟合"></p><p><font color="#FF1493">出现原因</font></p><ol><li><strong>训练数据集样本单一，样本不足。</strong> 如果训练样本只有负样本，然后那生成的模型去预测正样本，这肯定预测不准。所以训练样本要尽可能的全面，覆盖所有的数据类型。</li><li><strong>训练数据中噪声干扰过大。</strong> 噪声指训练数据中的干扰数据。过多的干扰会导致记录了很多噪声特征，忽略了真实输入和输出之间的关系。</li><li><strong>模型过于复杂</strong>。模型太复杂，已经能够“死记硬背”记下了训练数据的信息，但是遇到没有见过的数据的时候不能够变通，泛化能力太差。我们希望模型对不同的模型都有稳定的输出。模型太复杂是过拟合的重要因素。</li></ol><p><strong><font color="#FF8C00">如何防止过拟合</font></strong><br>要想解决过拟合问题，就要显著减少测试误差而不过度增加训练误差，从而提高模型的泛化能力。我们可以使用正则化（Regularization）方法。</p><blockquote><p>正则化是指修改学习算法，使其降低泛化误差而非训练误差。</p></blockquote><h3 id="正则化方法"><a href="#正则化方法" class="headerlink" title="正则化方法"></a>正则化方法</h3><blockquote><p>常用的正则化方法根据具体的使用<font color="#D2691E">策略</font>不同可分为：<br>（1）直接提供正则化约束的参数正则化方法，如L1/L2正则化；<br>（2）通过工程上的技巧来实现更低泛化误差的方法，如提前终止(Early stopping)和Dropout；<br>（3）不直接提供约束的隐式正则化方法，如数据增强等。</p></blockquote><ol><li> 获取和使用更多的数据（数据集增强）——解决过拟合的<font color="#DC143C">根本性</font>方法</li></ol><p>让机器学习或深度学习模型泛化能力更好的办法就是使用更多的数据进行训练。但是，在实践中，我们拥有的数据量是有限的。解决这个问题的一种方法就是<font color="#7FFF00">创建“假数据”并添加到训练集中——数据集增强</font>。通过增加训练集的额外副本来增加训练集的大小，进而改进模型的泛化能力。</p><ol start="2"><li>采用合适的模型（控制模型的复杂度）</li></ol><p>过于复杂的模型会带来过拟合问题。对于模型的设计，目前公认的一个深度学习规律”deeper is better”。国内外各种大牛通过实验和竞赛发现，对于CNN来说，层数越多效果越好，但是也更容易产生过拟合，并且计算所耗费的时间也越长。</p><p>根据<font color="#E9967A">奥卡姆剃刀</font>法则：在同样能够解释已知观测现象的假设中，我们应该挑选“最简单”的那一个。对于模型的设计而言，我们应该选择简单、合适的模型解决复杂的问题。</p><ol start="3"><li>降低特征的数量</li></ol><p>对于一些特征工程而言，可以降低特征的数量——<font color="#006400">删除冗余特征</font>，人工选择保留哪些特征。这种方法也可以解决过拟合问题。</p><ol start="4"><li>L1 / L2 正则化</li></ol><p><a href="https://www.cnblogs.com/zingp/p/10375691.html#_label0">深入理解L1、L2正则化 - ZingpLiu - 博客园</a></p><ul><li>L1正则化</li></ul><p>L1正则化可以使得参数稀疏化，即得到的参数是一个稀疏矩阵，可以用于特征选择。</p><pre><code>    稀疏性，说白了就是模型的很多参数是0。通常机器学习中特征数量很多，例如文本处理时，如果将一个词组（term）作为一个特征，那么特征数量会达到上万个（bigram）。在预测或分类时，那么多特征显然难以选择，但是如果代入这些特征得到的模型是一个稀疏模型，很多参数是0，表示只有少数特征对这个模型有贡献，绝大部分特征是没有贡献的，即使去掉对模型也没有什么影响，此时我们就可以只</code></pre><p>在原始的损失函数后面加上一个L1正则化项，即<strong>全部权重 $w$ 的绝对值的和，再乘以λ/n</strong>。则损失函数变为：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi><mo>=</mo><msub><mi>C</mi><mn>0</mn></msub><mo>+</mo><mfrac><mi>&#x3BB;</mi><mi>n</mi></mfrac><munder><mo>&#x2211;</mo><mi>i</mi></munder><mfenced close="|" open="|"><msub><mi>w</mi><mi>i</mi></msub></mfenced></math></p><p>对应的梯度（导数）：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><mo>&#x2202;</mo><mi>C</mi></mrow><mrow><mo>&#x2202;</mo><mi>w</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mo>&#x2202;</mo><msub><mi>C</mi><mn>0</mn></msub></mrow><mrow><mo>&#x2202;</mo><mi>w</mi></mrow></mfrac><mo>+</mo><mfrac><mi>&#x3BB;</mi><mi>n</mi></mfrac><mo>sgn</mo><mo>(</mo><mi>w</mi><mo>)</mo></math></p><p>其中 <math xmlns="http://www.w3.org/1998/Math/MathML"><mo>sgn</mo><mo>(</mo><mi>w</mi><mo>)</mo></math> 只是简单地取 $w1$ 各个元素地正负号。</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>sgn</mo><mo>(</mo><mi>w</mi><mo>)</mo><mo>=</mo><mfenced close="" open="{"><mtable columnalign="left"><mtr><mtd><mn>1</mn><mo>,</mo><mi>w</mi><mo>&gt;</mo><mn>0</mn></mtd></mtr><mtr><mtd><mn>0</mn><mo>,</mo><mi>w</mi><mo>=</mo><mn>0</mn></mtd></mtr><mtr><mtd><mo>-</mo><mn>1</mn><mo>,</mo><mi>w</mi><mo>&lt;</mo><mn>0</mn></mtd></mtr></mtable></mfenced></math></p><p>梯度下降时权重 $w$ 更新变为：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>w</mi><mo>&#x2192;</mo><msup><mi>w</mi><mo>‘</mo></msup><mo>=</mo><mi>w</mi><mo>-</mo><mfrac><mrow><mi>&#x3B7;</mi><mi>&#x3BB;</mi></mrow><mi>n</mi></mfrac><mo>sgn</mo><mo>(</mo><mi>w</mi><mo>)</mo><mo>-</mo><mi>&#x3B7;</mi><mfrac><mrow><mo>&#x2202;</mo><msub><mi>C</mi><mn>0</mn></msub></mrow><mrow><mo>&#x2202;</mo><mi>w</mi></mrow></mfrac></math></p><p>当 $w=0$ 时，|w|是不可导的。所以我们仅仅能依照原始的未经正则化的方法去更新 $w$  。<br>当 $w&gt;0$  时，sgn( $w$  )&gt;0, 则梯度下降时更新后的 $w$  变小。<br>当 $w&lt;0$  时，sgn( $w$  )&gt;0, 则梯度下降时更新后的 $w$  变大。换句换说，L1正则化使得权重 $w$ 往0靠，使网络中的权重尽可能为0，也就相当于减小了网络复杂度，防止过拟合。</p><p>这也就是<font color="#6495ED">L1正则化会产生更稀疏（sparse）的解</font>的原因。此处稀疏性指的是最优值中的一些参数为0。<font color="#1E90FF">L1正则化的稀疏性质已经被广泛地应用于特征选择</font>机制，从可用的特征子集中选择出有意义的特征。</p><ul><li>L2 正则化</li></ul><p>L2正则化可以防止模型过拟合（overfitting）；一定程度上，L1也可以防止过拟合。</p><p>拟合过程中通常都倾向于让权值尽可能小，最后构造一个所有参数都比较小的模型。因为一般认为参数值小的模型比较简单，能适应不同的数据集，也在一定程度上避免了过拟合现象。可以设想一下对于一个线性回归方程，若参数很大，那么只要数据偏移一点点，就会对结果造成很大的影响；但如果参数足够小，数据偏移得多一点也不会对结果造成什么影响，专业一点的说法是抗扰动能力强。</p><p>L2正则化通常被称为<strong>权重衰减</strong>（weight decay），就是在原始的损失函数后面再加上一个L2正则化项，即<strong>全部权重</strong> $w$  的平方和，再乘以λ/2n。则损失函数变为：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>C</mi><mo>=</mo><msub><mi>C</mi><mn>0</mn></msub><mo>+</mo><mfrac><mi>&#x3BB;</mi><mrow><mn>2</mn><mi>n</mi></mrow></mfrac><mo>&#xB7;</mo><mo>&#x2211;</mo><msubsup><mi>w</mi><mi>i</mi><mn>2</mn></msubsup></math></p><p>对应的梯度（导数）：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><mo>&#x2202;</mo><mi>C</mi></mrow><mrow><mo>&#x2202;</mo><mi>w</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mo>&#x2202;</mo><msub><mi>C</mi><mn>0</mn></msub></mrow><mrow><mo>&#x2202;</mo><mi>w</mi></mrow></mfrac><mo>+</mo><mfrac><mi>&#x3BB;</mi><mi>n</mi></mfrac><mi>w</mi></math></p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><mo>&#x2202;</mo><mi>C</mi></mrow><mrow><mo>&#x2202;</mo><mi>b</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mo>&#x2202;</mo><msub><mi>C</mi><mn>0</mn></msub></mrow><mrow><mo>&#x2202;</mo><mi>b</mi></mrow></mfrac></math></p><p>能够发现L2正则化项对偏置 b 的更新没有影响，可是对于权重 $w$  的更新有影响：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>w</mi><mo>&#x2192;</mo><mi>w</mi><mo>-</mo><mi>&#x3B7;</mi><mfrac><mrow><mo>&#x2202;</mo><msub><mi>C</mi><mn>0</mn></msub></mrow><mrow><mo>&#x2202;</mo><mi>w</mi></mrow></mfrac><mo>-</mo><mfrac><mrow><mi>&#x3B7;</mi><mi>&#x3BB;</mi></mrow><mi>n</mi></mfrac><mi>w</mi></math><br><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>=</mo><mfenced><mrow><mn>1</mn><mo>-</mo><mfrac><mrow><mi>&#x3B7;</mi><mi>&#x3BB;</mi></mrow><mi>n</mi></mfrac></mrow></mfenced><mi>w</mi><mo>-</mo><mi>&#x3B7;</mi><mfrac><mrow><mo>&#x2202;</mo><msub><mi>C</mi><mn>0</mn></msub></mrow><mrow><mo>&#x2202;</mo><mi>w</mi></mrow></mfrac></math><br>这里的<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3B7;</mi></math>、 $n$ 、<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3BB;</mi></math>都是大于0的， 所以 <math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn><mo>-</mo><mfrac><mrow><mi>&#x3B7;</mi><mi>&#x3BB;</mi></mrow><mi>n</mi></mfrac></math>小于1。因此在梯度下降过程中，权重 $w$ 将逐渐减小，趋向于0但不等于0。这也就是<strong>权重衰减</strong>（weight decay）的由来。</p><p>L2正则化起到使得权重参数 $w$ 变小的效果，为什么能防止过拟合呢？因为更小的权重参数  意味着模型的复杂度更低，对训练数据的拟合刚刚好，不会过分拟合训练数据，从而提高模型的泛化能力。</p><ol start="5"><li>Dropout</li></ol><p>  Dropout是在训练网络时用的一种技巧（trike），相当于在隐藏单元增加了噪声。<strong>Dropout 指的是在训练过程中每次按一定的概率（比如50%）随机地“删除”一部分隐藏单元（神经元）</strong>。所谓的“删除”不是真正意义上的删除，其实就是将该部分神经元的激活函数设为0（激活函数的输出为0），让这些神经元不计算而已。</p><p>  <img src="https://gitee.com/merlynr/img-store/raw/master/2021531/1622466578527.png" alt="Dropout"></p><p><font color="#006400">  <strong>Dropout为什么有助于防止过拟合呢？</strong></font></p><p>（a）在训练过程中会产生不同的训练模型，不同的训练模型也会产生不同的的计算结果。随着训练的不断进行，计算结果会在一个范围内波动，但是均值却不会有很大变化，因此可以把最终的训练结果看作是不同模型的平均输出。<br>（b）它消除或者减弱了神经元节点间的联合，降低了网络对单个神经元的依赖，从而增强了泛化能力。</p><blockquote><p><font color="#00008B">理解</font><br>通过加入噪声，在训练模型时，扩展模型的接受范围，避免过拟合</p></blockquote><ol start="6"><li>Early stopping（提前终止）</li></ol><p>对模型进行训练的过程即是对模型的参数进行学习更新的过程，这个参数学习的过程往往会用到一些迭代方法，如梯度下降（Gradient descent）。Early stopping是一种迭代次数截断的方法来防止过拟合的方法，<font color="#7FFF00">即在模型对训练数据集迭代收敛之前停止迭代来防止过拟合</font>。</p><p>为了获得性能良好的神经网络，训练过程中可能会经过很多次epoch（遍历整个数据集的次数，一次为一个epoch）。如果epoch数量太少，网络有可能发生欠拟合；如果epoch数量太多，则有可能发生过拟合。Early stopping旨在解决epoch数量需要手动设置的问题。具体做法：每个epoch（或每N个epoch）结束后，在验证集上获取测试结果，随着epoch的增加，如果在验证集上发现测试误差上升，则停止训练，将停止之后的权重作为网络的最终参数。</p><p><font color="#E9967A">为什么能防止过拟合？</font></p><p>当还未在神经网络运行太多迭代过程的时候，w参数[误差]接近于0，因为随机初始化w值的时候，它的值是较小的随机值。当你开始迭代过程，w的值会变得越来越大。到后面时，w的值已经变得十分大了。所以early stopping要做的就是在中间点停止迭代过程。我们将会得到一个中等大小的w参数，会得到与L2正则化相似的结果，选择了w参数较小的神经网络。</p><p><font color="#A52A2A">Early Stopping缺点</font><br><strong>没有采取不同的方式来解决优化损失函数和过拟合这两个问题</strong>，而是用一种方法同时解决两个问题 ，结果就是要考虑的东西变得更复杂。之所以不能独立地处理，因为如果你停止了优化损失函数，你可能会发现损失函数的值不够小，同时你又不希望过拟合。</p>]]></content>
    
    
    <summary type="html">机器学习</summary>
    
    
    
    <category term="machine learning" scheme="https://merlynr.github.io/categories/machine-learning/"/>
    
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="machine learning" scheme="https://merlynr.github.io/tags/machine-learning/"/>
    
    <category term="algorithm" scheme="https://merlynr.github.io/tags/algorithm/"/>
    
    <category term="data mining" scheme="https://merlynr.github.io/tags/data-mining/"/>
    
  </entry>
  
  <entry>
    <title>算法的性能指标</title>
    <link href="https://merlynr.github.io/2021/05/31/%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/"/>
    <id>https://merlynr.github.io/2021/05/31/%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</id>
    <published>2021-05-30T16:00:00.000Z</published>
    <updated>2021-05-30T16:00:00.000Z</updated>
    
    
    <summary type="html">=</summary>
    
    
    
    <category term="algorithm" scheme="https://merlynr.github.io/categories/algorithm/"/>
    
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="algorithm" scheme="https://merlynr.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>kernal</title>
    <link href="https://merlynr.github.io/2021/05/30/kernal/"/>
    <id>https://merlynr.github.io/2021/05/30/kernal/</id>
    <published>2021-05-29T16:00:00.000Z</published>
    <updated>2021-05-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><font color="#6495ED">核方法</font>是一类把低维空间的非线性可分问题，转化为高维空间的线性可分问题的方法。</p><blockquote><p><font color="#A9A9A9">理论基础:</font>核方法的理论基础是Cover’s theorem，指的是<font color="#FF8C00">对于非线性可分的训练集，可以大概率通过将其非线性映射到一个高维空间来转化成线性可分的训练集。</font></p></blockquote><p><font color="#9400D3">核函数</font>是映射关系 的内积，映射函数本身仅仅是一种映射关系，并没有增加维度的特性，不过可以利用核函数的特性，构造可以增加维度的核函数。</p><p>设 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">X</mi></math>是输入空间（即 <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mi>i</mi></msub><mo>&#x2208;</mo><mi mathvariant="script">X</mi></math> ， <math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">X</mi></math>  是 <math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi mathvariant="normal">&#x211D;</mi><mi>n</mi></msup></math> 的子集或离散集合 ），又设<math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">H</mi></math>  为特征空间（<math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">H</mi></math> 是希尔伯特空间），如果存在一个从 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">X</mi></math> 到 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">H</mi></math> 的映射</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3D5;</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>:</mo><mi mathvariant="script">X</mi><mo>&#x2192;</mo><mi mathvariant="script">H</mi></math></p><p>使得对所有 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>x</mi><mo>,</mo><mi>z</mi><mo>&#x2208;</mo><mi mathvariant="script">X</mi></math>,函数<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi><mo>(</mo><mi>x</mi><mo>,</mo><mi>z</mi><mo>)</mo></math>满足条件</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi><mo>(</mo><mi>x</mi><mo>,</mo><mi>z</mi><mo>)</mo><mo>=</mo><mo>&#x27E8;</mo><mi>&#x3D5;</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>,</mo><mi>&#x3D5;</mi><mo>(</mo><mi>z</mi><mo>)</mo><mo>&#x27E9;</mo></math></p><p>则称 $K$ 为核函数。其中 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3D5;</mi><mo>(</mo><mi>x</mi><mo>)</mo></math> 为映射函数， <math xmlns="http://www.w3.org/1998/Math/MathML"><mo>&#x27E8;</mo><mo>&#xB7;</mo><mo>,</mo><mo>&#xB7;</mo><mo>&#x27E9;</mo></math>为内积。</p><p>即核函数输入两个向量，它返回的值<font color="#FF1493">等于</font>这两个向量分别作 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3D5;</mi></math> 映射然后点积【内积】的结果。</p><p><font color="#008B8B">核技巧</font>是一种利用核函数直接计算 <math xmlns="http://www.w3.org/1998/Math/MathML"><mo>&#x27E8;</mo><mi>&#x3D5;</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>,</mo><mi>&#x3D5;</mi><mo>(</mo><mi>z</mi><mo>)</mo><mo>&#x27E9;</mo></math> ，以避开分别计算<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3D5;</mi><mo>(</mo><mi>x</mi><mo>)</mo></math>  和<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3D5;</mi><mo>(</mo><mi>z</mi><mo>)</mo></math>  ，从而加速核方法计算的技巧。</p><blockquote><p><font color="#FF1493">注意</font><br>得益于<font color="#FF8C00">SVM对偶问题</font>的表现形式，核技巧可以应用于SVM。<br><font color="#7FFF00">TODO  </font>没有了解<br>核函数的选择是SVM的<font color="#B8860B">最大变数</font>，如果核函数选择不适，那么  将不能将输入空间映射到线性可分的特征空间。</p></blockquote><h2 id="判断核函数"><a href="#判断核函数" class="headerlink" title="判断核函数"></a>判断核函数</h2><p><font color="#bf242a">不知道 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3D5;</mi></math> 的情况下，如何判断某个 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi></math> 是不是核函数？</font></p><p><strong>答案:</strong> 是 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi></math> 是核函数当且仅当对任意数据 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>D</mi><mo>=</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><mo>&#x2026;</mo><mo>,</mo><msub><mi>x</mi><mi>m</mi></msub></math> ，核矩阵(kernal matrix,gram matrix)总是半正定的</p><blockquote><p><font color="#368AF8">知识补充：</font><strong>实对称矩阵</strong><br>如果有n阶矩阵A，其矩阵的元素都为实数，且矩阵A的转置等于其本身（aij=aji），(i,j为元素的脚标），则称A为实对称矩阵。</p></blockquote><blockquote><p><font color="#6495ED"><a href="https://zhuanlan.zhihu.com/p/44860862">知识补充</a>：</font><font color="#8B0000">「正定矩阵」(positive definite)</font>和<font color="#8B0000">「半正定矩阵」(positive semi-definite)</font><br><strong>正定矩阵：</strong> 给定一个大小为 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>&#xD7;</mo><mi>n</mi></math> 的实对称矩阵<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi></math>  ，若对于任意长度为 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math> 的<font color="#A66766">非零向量</font> <math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="bold-italic">x</mi></math>，有 <math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi mathvariant="bold-italic">x</mi><mi>T</mi></msup><mi>A</mi><mi mathvariant="bold-italic">x</mi><mo>&gt;</mo><mn>0</mn></math> 恒成立，则矩阵 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi></math>  是一个正定矩阵。<br><strong>半正定矩阵：</strong> 给定一个大小为 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi><mo>&#xD7;</mo><mi>n</mi></math> 的实对称矩阵<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi></math>  ，若对于任意长度为 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math> 的<font color="#A66766">向量</font> <math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="bold-italic">x</mi></math>，有 <math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi mathvariant="bold-italic">x</mi><mi>T</mi></msup><mi>A</mi><mi mathvariant="bold-italic">x</mi><mo>&gt;</mo><mn>0</mn></math> 恒成立，则矩阵 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>A</mi></math>  是一个正定矩阵。<br><font color="#FF00FF">半正定矩阵包括了正定矩阵，核矩阵与协方差矩阵都要半正定</font></p></blockquote><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021530/1622369097125.png" alt="核矩阵"></p><h2 id="常用核函数"><a href="#常用核函数" class="headerlink" title="常用核函数"></a>常用核函数</h2><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021530/1622366953315.png" alt="常用核函数"></p><h2 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h2><p>举一个<a href="https://zhuanlan.zhihu.com/p/95362628">栗子</a><br>下面这张图位于第一、二象限内。我们关注红色的门，以及“北京四合院”这几个字下面的紫色的字母。我们把红色的门上的点看成是“+”数据，紫色字母上的点看成是“-”数据，它们的横、纵坐标是两个特征。显然，在这个二维空间内，“+”“-”两类数据不是线性可分的。</p><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021530/1622369536767.png" alt="二维"></p><p>我们现在考虑核函数<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi><mfenced><mrow><msub><mi>v</mi><mn>1</mn></msub><mo>,</mo><msub><mi>v</mi><mn>2</mn></msub></mrow></mfenced><mo>=</mo><mo>&lt;</mo><msub><mi>v</mi><mn>1</mn></msub><mo>,</mo><msub><mi>v</mi><mn>2</mn></msub><msup><mo>&gt;</mo><mn>2</mn></msup></math>，即“内积平方”。<br>这里面<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>v</mi><mn>1</mn></msub><mo>=</mo><mfenced><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>y</mi><mn>1</mn></msub></mrow></mfenced><mo>,</mo><msub><mi>v</mi><mn>2</mn></msub><mo>=</mo><mfenced><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><msub><mi>y</mi><mn>2</mn></msub></mrow></mfenced></math>是二维空间中的两个点。</p><p>这个核函数对应着一个二维空间到三维空间的映射，它的表达式是：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>P</mi><mo>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>)</mo><mo>=</mo><mfenced><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>,</mo><msqrt><mn>2</mn></msqrt><mi>x</mi><mi>y</mi><mo>,</mo><msup><mi>y</mi><mn>2</mn></msup></mrow></mfenced></math><br>可以验证，<br><img src="https://gitee.com/merlynr/img-store/raw/master/2021530/1622369667776.png" alt="核函数"></p><p>在P这个映射下，原来二维空间中的图在三维空间中的像是这个样子：</p><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021530/1622369693244.png" alt="三维"></p><p><font color="#D2691E">注意</font>到绿色的平面可以完美地分割红色和紫色，也就是说，两类数据在三维空间中变成线性可分的了。</p><p>而三维中的这个判决边界，再映射回二维空间中是这样的：</p><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021530/1622369730773.png" alt="再二维"></p><p>这是一条双曲线，它不是线性的。</p><p><font color="#A52A2A">通过高维映射使得特征线性可分，换种思路就是当两个特征值无法将数据分开时，就将两个特征值进行点交，形成第三个特征，这个时候就有三个特征值，然后构成三位空间，进行分类</font></p>]]></content>
    
    
    <summary type="html">核函数相关的笔记</summary>
    
    
    
    <category term="algorithm" scheme="https://merlynr.github.io/categories/algorithm/"/>
    
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="algorithm" scheme="https://merlynr.github.io/tags/algorithm/"/>
    
    <category term="data mining" scheme="https://merlynr.github.io/tags/data-mining/"/>
    
    <category term="kernal method" scheme="https://merlynr.github.io/tags/kernal-method/"/>
    
    <category term="kernal trick" scheme="https://merlynr.github.io/tags/kernal-trick/"/>
    
    <category term="kernal function" scheme="https://merlynr.github.io/tags/kernal-function/"/>
    
  </entry>
  
  <entry>
    <title>协方差矩阵</title>
    <link href="https://merlynr.github.io/2021/05/26/%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5/"/>
    <id>https://merlynr.github.io/2021/05/26/%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5/</id>
    <published>2021-05-25T16:00:00.000Z</published>
    <updated>2021-05-26T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方差和协方差的定义"><a href="#方差和协方差的定义" class="headerlink" title="方差和协方差的定义"></a>方差和协方差的定义</h2><p><font color="#184471"><strong>方差</strong>：</font>用来度量单个随机变量的离散程度</p><p>$$\sigma_{x}^{2}=\frac{1}{n-1} \sum_{i=1}^{n}\left(x_{i}-\bar{x}\right)^{2}$$</p><p><font color="#D3B2F7">为什么样本方差的分母是n-1？</font></p><pre><code>最简单的原因，是因为因为均值已经用了n个数的平均来做估计在求方差时，只有(n-1)个数和均值信息是不相关的。而你的第ｎ个数已经可以由前(n-1)个数和均值　来唯一确定，实际上没有信息量。所以在计算方差时，只除以(n-1)。</code></pre><p><font color="#0C5F6C"><strong>协方差</strong>：</font>一般用来刻画两个随机变量的相似程度</p><p>$$\sigma(x, y)=\frac{1}{n-1} \sum_{i=1}^{n}\left(x_{i}-\bar{x}\right)\left(y_{i}-\bar{y}\right)$$</p><p>在公式中，符号 $\bar{x}, \bar{y}$ 分别表示两个随机变量所对应的观测样本均值，据此，我们发现：方差 $\sigma_{x}^{2}$ 可视作随机变量 x 关于其自身的协方差 $\sigma(x, x)$ .</p><h2 id="从方差-协方差到协方差矩阵"><a href="#从方差-协方差到协方差矩阵" class="headerlink" title="从方差/协方差到协方差矩阵"></a>从方差/协方差到协方差矩阵</h2><p>根据方差的定义，给定 $d$ 个随机变量 $x_{k},k=1,2,\ldots,d$ ，则这些随机变量的方差为<br>$$\sigma\left(x_{k},x_{k}\right)=\frac{1}{n-1}\sum_{i=1}^{n}\left(x_{k i}-\bar{x}_{k}\right)^{2},k=1,2,\ldots,d$$</p><p> $x_{k i}$ 表示随机变量 $x_{k}$ 中的第 $i$ 个观测样本，$n$  表示样本量，每个随机变量所对应的观测样本数量均为 $n$ 。<br> 对于这些随机变量，我们还可以根据协方差的定义，求出<strong>两两之间的协方差</strong>，即<br> <img src="https://gitee.com/merlynr/img-store/raw/master/2021527/1622097407978.png"></p><p> 因此，协方差矩阵为 $$\Sigma=\left[\begin{array}{ccc}\sigma\left(x_{1}, x_{1}\right)&amp;\cdots&amp;\sigma\left(x_{1},x_{d}\right)\\vdots&amp;\ddots&amp;\vdots\\sigma\left(x_{d},x_{1}\right)&amp;\cdots&amp;\sigma\left(x_{d},x_{d}\right)\end{array}\right]\in\mathbb{R}^{d\times d}$$<br>其中，对角线上的元素为各个随机变量的方差，非对角线上的元素为两两随机变量之间的协方差，根据协方差的定义，我们可以认定：矩阵 $\Sigma$ 为<font color="#AB8E35">对称矩阵</font>(symmetric matrix)，其大小为 $d$ x $d$ 。</p><h2 id="多元正态分布与线性变换"><a href="#多元正态分布与线性变换" class="headerlink" title="多元正态分布与线性变换"></a>多元正态分布与线性变换</h2><blockquote><p><font color="#EFED2E">多元正态分布</font>—n维的多元正态分布，也称为多元高斯分布</p></blockquote><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021526/1622033779880.png" alt="多元正态分布图"></p><p>假设一个向量 $x$ 服从均值向量为 $\boldsymbol{\mu}$ 、协方差矩阵为 $\Sigma$ 的多元正态分布(multi-variate Gaussian distribution)【第二章】，则 $$p(\boldsymbol{x})=|2 \pi \Sigma|^{-1 / 2} \exp \left(-\frac{1}{2}(\boldsymbol{x}-\boldsymbol{\mu})^{T} \Sigma^{-1}(\boldsymbol{x}-\boldsymbol{\mu})\right)$$</p><blockquote><p><font color="#DE8937">联立理解：</font>多元正态分布<br><img src="https://gitee.com/merlynr/img-store/raw/master/2021526/1622035698486.png" alt="多元正态分布"></p></blockquote><p>令该分布的均值向量为 $\boldsymbol{\mu}=\mathbf{0}$ ，由于指数项外面的系数 $|2 \pi \Sigma|^{-1 / 2}$ 通常作为常数，故可将多元正态分布简化为 $$p(\boldsymbol{x}) \propto \exp \left(-\frac{1}{2} \boldsymbol{x}^{T} \Sigma^{-1} \boldsymbol{x}\right)$$<br>再令 $\boldsymbol{x}=(y, z)^{T}$ ，包含两个随机变量 $y$ 和 $z$ ，则协方差矩阵可写成如下形式： $$ \Sigma=\left[\begin{array}{ll}\sigma(y, y) &amp; \sigma(y, z) \ \sigma(z, y) &amp; \sigma(z, z)\end{array}\right] \in \mathbb{R}^{2 \times 2} $$<br>用<font color="#006EFF">单位矩阵</font>(identity matrix) $I$ 作为<font color="#183D66">协方差矩阵</font>，随机变量 $y$ 和 $z$ 的方差均为1，则生成如干个随机数如图所示。 </p><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021526/1622038800402.png" alt="图1二元正态分布"></p><blockquote><p><font color="#DE8937">知识补充：</font>单位矩阵<br> 单位矩阵是个方阵，从左上角到右下角的对角线（称为主对角线）上的元素均为1。除此以外全都为0。<strong>任何矩阵与单位矩阵相乘都等于本身</strong><br><img src="https://gitee.com/merlynr/img-store/raw/master/2021526/1622039427482.png" alt="单位矩阵"></p></blockquote><p>在生成的若干个随机数中，每个点的似然为 $$ \mathcal{L}(\boldsymbol{x}) \propto \exp \left(-\frac{1}{2} \boldsymbol{x}^{T} \boldsymbol{x}\right) $$</p><blockquote><p><font color="">知识补充：</font>线性变换<br><a href="https://www.bilibili.com/video/av6043439">视频教学</a><br>线性性质一：直线在变换后仍然保持为直线，不能弯曲；线性性质二：原点是固定不变的</p></blockquote><p>对图[二元正态分布]中的所有点考虑一个线性变换(linear transformation)：$\boldsymbol{t}=A \boldsymbol{x}$  ，我们能够得到图</p><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021526/1622039676816.png" alt="图2 经过线性变换的二元正态分布，先将图1的纵坐标压缩0.5倍，再将所有点逆时针旋转30°得到"></p><p>在线性变换中，矩阵 $A$ 被称为<strong>变换矩阵</strong>(transformation matrix)，为了将图1中的点经过线性变换得到我们想要的图2，其实我们需要构造两个矩阵：</p><ul><li><strong>尺度矩阵</strong>(scaling matrix)： $$S=\left[\begin{array}{cc}s_{y}&amp;0\0&amp;s_{z}\end{array}\right]$$</li><li><strong>旋转矩阵</strong>(rotation matrix)： $$R=\left[\begin{array}{cc}\cos(\theta)&amp;-\sin(\theta)\\sin(\theta)&amp;\cos(\theta)\end{array}\right]$$<br>其中， $\theta$ 为顺时针旋转的度数。</li></ul><blockquote><p><font color="#8591A6">补充知识：</font>变换矩阵、尺度矩阵和旋转矩阵三者的关系式<br>$A=R S$</p></blockquote><p>在这个例子中，尺度矩阵为 $S=\left[\begin{array}{l l}1&amp;0\0&amp;\frac{1}{2}\end{array}\right]$ ，旋转矩阵为 $R=\left[\begin{array}{c c}\cos\left(-\frac{\pi}{6}\right)&amp;-\sin\left(-\frac{\pi}{6}\right)\\sin\left(-\frac{\pi}{6}\right)&amp;\cos\left(-\frac{\pi}{6}\right)\end{array}\right]=\left[\begin{array}{c c}\frac{\sqrt{3}}{2}&amp;\frac{1}{2}\-\frac{1}{2}&amp;\frac{\sqrt{3}}{2}\end{array}\right]$ ，故变换矩阵为 $A=R S=\left[\begin{array}{cc}\frac{\sqrt{3}}{2}&amp;\frac{1}{4}\-\frac{1}{2}&amp;\frac{\sqrt{3}}{4}\end{array}\right]$</p><p>另外，需要考虑的是，经过了线性变换，$t$  的分布是什么样子呢？</p><p>将 $\boldsymbol{x}=A^{-1} \boldsymbol{t}$ 带入前面给出的似然 $\mathcal{L}(\boldsymbol{x})$ ，有 $\mathcal{L}(\boldsymbol{t}) \propto \exp \left(-\frac{1}{2}\left(A^{-1} \boldsymbol{t}\right)^{T}\left(A^{-1} \boldsymbol{t}\right)\right)$<br>$=\exp \left(-\frac{1}{2} \boldsymbol{t}^{T}\left(A A^{T}\right)^{-1} \boldsymbol{t}\right)$</p><p>由此可以得到，多元正态分布的协方差矩阵为 $$\Sigma=A A^{T}=\left[\begin{array}{cc}\frac{\sqrt{3}}{2} &amp; \frac{1}{4} \ -\frac{1}{2} &amp; \frac{\sqrt{3}}{4}\end{array}\right]\left[\begin{array}{cc}\frac{\sqrt{3}}{2} &amp; -\frac{1}{2} \ \frac{1}{4} &amp; \frac{\sqrt{3}}{4}\end{array}\right]=\left[\begin{array}{cc}\frac{13}{16} &amp; -\frac{3 \sqrt{3}}{16} \ -\frac{3 \sqrt{3}}{16} &amp; \frac{7}{16}\end{array}\right]$$</p><h2 id="协方差矩阵的特征值分解"><a href="#协方差矩阵的特征值分解" class="headerlink" title="协方差矩阵的特征值分解"></a>协方差矩阵的特征值分解</h2><blockquote><p>回到我们已经学过的线性代数内容，对于任意对称矩阵 $\Sigma$ ，存在一个特征值分解(eigenvalue decomposition, EVD)： $$\Sigma=U \Lambda U^{T}$$ 其中, $U$ 的每一列都是相互正交的特征向量，且是单位向量，满足 $U^{T}U=I$ ， $\Lambda$ 对角线上的元素是从大到小排列的特征值，非对角线上的元素均为0。</p></blockquote><p>当然，这条公式在这里也可以很容易地写成如下形式： $$\Sigma=\left(U \Lambda^{1 / 2}\right)\left(U \Lambda^{1 / 2}\right)^{T}=A A^{T}$$<br>其中，$A=U \Lambda^{1 / 2}$  ，因此，通俗地说，<font color="#226771">任意一个协方差矩阵都可以视为线性变换的结果。</font><br>在上面的例子中，<strong>特征向量构成的矩阵</strong>为 $$U=R=\left[\begin{array}{cc}\cos (\theta) &amp; -\sin (\theta) \ \sin (\theta) &amp; \cos (\theta)\end{array}\right]=\left[\begin{array}{cc}\frac{\sqrt{3}}{2} &amp; \frac{1}{2} \ -\frac{1}{2} &amp; \frac{\sqrt{3}}{2}\end{array}\right]$$<br><strong>特征值构成的矩阵</strong>为<br>$$\Lambda=S S^{T}=\left[\begin{array}{cc}s_{y}^{2} &amp; 0 \ 0 &amp; s_{z}^{2}\end{array}\right]=\left[\begin{array}{ll}1 &amp; 0 \ 0 &amp; \frac{1}{4}\end{array}\right]$$<br>到这里，我们发现：多元正态分布的概率密度是由<font color="#BD5A5D">协方差矩阵的特征向量控制旋转(rotation)</font>，<font color="">特征值控制尺度(scale)</font>，除了协方差矩阵，<font color="#810006">均值向量会控制概率密度的位置</font>，在图1和图2中，均值向量为 $0$ ，因此，概率密度的中心位于坐标原点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;方差和协方差的定义&quot;&gt;&lt;a href=&quot;#方差和协方差的定义&quot; class=&quot;headerlink&quot; title=&quot;方差和协方差的定义&quot;&gt;&lt;/a&gt;方差和协方差的定义&lt;/h2&gt;&lt;p&gt;&lt;font color=&quot;#184471&quot;&gt;&lt;strong&gt;方差&lt;/strong&gt;：</summary>
      
    
    
    
    <category term="algorithm" scheme="https://merlynr.github.io/categories/algorithm/"/>
    
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="algorithm" scheme="https://merlynr.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://merlynr.github.io/2021/05/25/2020-10-13daily/"/>
    <id>https://merlynr.github.io/2021/05/25/2020-10-13daily/</id>
    <published>2021-05-25T02:22:55.509Z</published>
    <updated>2021-05-26T11:50:22.283Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>挖掘业务流程，结合机器学习进行业务预测分析</title>
    <link href="https://merlynr.github.io/2021/05/25/%E6%8C%96%E6%8E%98%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%EF%BC%8C%E7%BB%93%E5%90%88%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%BF%9B%E8%A1%8C%E4%B8%9A%E5%8A%A1%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90/"/>
    <id>https://merlynr.github.io/2021/05/25/%E6%8C%96%E6%8E%98%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%EF%BC%8C%E7%BB%93%E5%90%88%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%BF%9B%E8%A1%8C%E4%B8%9A%E5%8A%A1%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90/</id>
    <published>2021-05-24T16:00:00.000Z</published>
    <updated>2021-05-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基于机器学习的流程异常预测行为"><a href="#基于机器学习的流程异常预测行为" class="headerlink" title="基于机器学习的流程异常预测行为"></a>基于机器学习的流程异常预测行为</h2><p><img src="./attachments/%E5%9F%BA%E4%BA%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%B5%81%E7%A8%8B%E5%BC%82%E5%B8%B8%E9%A2%84%E6%B5%8B%E6%96%B9%E6%B3%95_%E9%AD%8F%E6%87%BF.pdf" alt="基于机器学习的流程异常预测方法_魏懿"></p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><blockquote><p>通过挖掘流程执行的<font color="#D2691E">日志记录</font> 和<font color="#6495ED">活动执行时间信息 </font>，基于机器学习方法的异常检测方法，实现实时预测业务流程中的超 期 异 常 和 流 程 行 为 异 常。</p></blockquote><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><blockquote><p>异常(预期的，完全意外的)</p></blockquote><ol><li>流程超期、资源不可用、活动执行失败等和完全意外的异常</li></ol><blockquote><p>现有的流程异常检测方法</p></blockquote><ul><li>主动 的 设 置 时 间 检 查点、动态检查，或 被动地基于异常发生后捕捉异常、处理异常的机制<ol><li>主动设置时间检查点的方法有两个弊端，第一个设置点的位置无法精确判断，第二个是系统状态是动态的，受生产环境等诸多条件影响，所以主动i设置会造成很多新的问题</li><li>被动处理超期异常的方法，失去了对业务流程管理的主动性，从而将导致工作流期望的目标延迟或付出更大的开销。【即失去对于流程预测的主动性】</li></ol></li></ul><h3 id="目前国内外研究动态"><a href="#目前国内外研究动态" class="headerlink" title="目前国内外研究动态"></a>目前国内外研究动态</h3><h4 id="基于时间边界的时间异常检测"><a href="#基于时间边界的时间异常检测" class="headerlink" title="基于时间边界的时间异常检测"></a>基于时间边界的时间异常检测</h4><ol><li>基于时间边界的时间异常检测–Eder</li></ol><p><font size=1>the fifth and sixth document of this paper </font></p><pre><code>首先要明确每个任务节点执行时间的上下边界， 基于这两个时限， 计算起始节点到当前节点的最佳（ 最短） 执行时间和最坏（ 最长） 执行时间。当流程执行时， 如果当前时间在区间内， 则判断为没有时间异常</code></pre><ol start="2"><li>基于关键路径</li></ol><p><font size=1>the seventh document of this paper </font></p><pre><code>在工作流执行前，会根据模型先找出关键路径， 并在流程执行时检查最佳完成时间与最终时限， 如果最佳完成时间大于最终时限， 则预测为异常</code></pre><h4 id="时间统计模型建立"><a href="#时间统计模型建立" class="headerlink" title="时间统计模型建立"></a>时间统计模型建立</h4><ol><li>执行时间建模方法</li></ol><p><font size=1>the eighth document of this paper </font></p><pre><code>该方法利用历史日志生成涵盖所有活动持续时间直方图来表示当前节点和末端节点之间的剩余执行时间的概率，用于捕获有关工作流执行的时间信息，定义计算工作流执行时间的必要操作</code></pre><ol start="2"><li>综合时间模型和流程步骤分析</li></ol><p><font size=1>the ninth document of this paper </font></p><pre><code>综合运用时间统计模型和通过多个步骤分析方法生成运行时间概率分布、计算异常概率、与阈值比较的方法，提出一种基于运行的异常预测算法来预测工作流中的时间异常，该算法分为即设计时段和运行时段两个阶段，在设计时段，生成该模型所有可能产生的运行轨迹，并计算它们的预计执行时间的概率分布；在运行时段，通过分析计算流程超时的可能性与预设的阈值做比较来判断是否预测为异常    </code></pre><ol start="3"><li>结合积极语义模型</li></ol><p><font size=1>the tenth document of this paper </font></p><pre><code>采用积极语义模型来捕捉各种工作流情形下的 语 义 特 征，并 且 检 测 和 处 理 异 常    </code></pre><ol start="4"><li>提出受启发与传染病模型的时间延迟传播模型</li></ol><p><font size=1>the eleventh document of this paper </font></p><pre><code>着眼于并行云工作流中的时间延迟，提出受启发与传染病模型的时间延迟传播模型，预测使云工作流中达到一定完成率的最大时间异常数目</code></pre><h3 id="离群点检测的算法"><a href="#离群点检测的算法" class="headerlink" title="离群点检测的算法"></a>离群点检测的算法</h3><p><a href="https://blog.zuishuailcq.xyz/2021/05/25/%E7%A6%BB%E7%BE%A4%E7%82%B9%E6%A3%80%E6%B5%8B/">离群点检测 | 吾辈之人，自当自强不息！</a></p><p><a href="https://blog.zuishuailcq.xyz/2021/05/31/%E5%AD%A4%E7%AB%8B%E6%A3%AE%E6%9E%97%EF%BC%88Isolation%20Forest%EF%BC%89/">孤立森林（Isolation Forest） | 吾辈之人，自当自强不息！</a></p><h2 id="本文"><a href="#本文" class="headerlink" title="本文"></a>本文</h2><h3 id="idea"><a href="#idea" class="headerlink" title="idea"></a>idea</h3><blockquote><p>提出一种基于活动执行时间和比例关系的方法，通过学习历史流程执行日志中活动时间信息，根据正在执行的待预测流程的日志及状态，预测其是否为异常流程以及异常的类型。并且，本文提出通过计算活动执行时间之间的比例关系作为流程特征加入机器学习算法，运用机器学习中监督学习的分类器以预测流程是否会发生超期异常（流程执行总时间超过预设最终期限），同时使用非监督学习的离群点检测算法根据历史数据中活动执行时间比例关系判定流程行为异常。结合两种算法的结果对流程异常预测做出进一步的分类和分析。</p></blockquote><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol><li>预处理历史和正在执行的流程数据，获得流程中活动执行时间序列以及计算活动执行时间<font color="#8B0000">比例关系</font></li><li>使用监督学习的分类器，预测并标记超期【流程执行<br>总时间超过预设最终期限】异常流程为<math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="normal">I</mi></math>类异常流程</li><li> 用无监督学习检测离群点算法【 <font color="#9400D3">活动执行时间之间比例关系(单个活动占总体)</font>为特征值】，找出历史数据中的异常流程并标记为<math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="normal">I</mi></math><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="normal">I</mi></math>类异常流程</li><li> 通过集成业务流程异常预测方法将待预测流程分为正常流程或者不同种类的异常流程</li></ol><h3 id="结构概述"><a href="#结构概述" class="headerlink" title="结构概述"></a>结构概述</h3><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021531/1622429405396.png" alt="集成业务流程异常预测方法结构图"></p><blockquote><p><font color="#8FBC8F">知识补充：</font>弱监督<br>不完全监督（Incomplete supervision）：训练数据中只有一部分数据被给了标签，有一些数据是没有标签的。<br>不确切监督（Inexact supervision）：训练数据只给出了粗粒度标签。可理解为只给了大类的标签，详细属性没有给标签<br>不精确监督（Inaccurate supervision）：给出的标签不总是正确的</p></blockquote><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021531/1622441386940.png" alt="预测结果异常分类韦恩图"></p><ol><li>第一类通过弱监督学习方法可以标记出大部分的异常流程，但是系统的运行情况很容易受环境资源影响，很多时候由于等待时间过长，被误标为异常流程，但是依旧属于正常流程</li><li>在实际业务流程中， 活动的执行时间之间并非独立分布， 而是具有隐含的相关关系， 由于多种因素的影响， 造成了活动时间相应的变化。比如工作负荷加倍使得某些活动花费了较长时间， 导致流程总时间较长， 有超期异常的风险。但是从活动执行时间比例关系来看， 流程时间可能被近乎等比例放大， 完全是合情合理的， 并不应该被记为最终期限异常的流程。在活动时间比例上， 正常执行的流程活动时间比例关系是相似的， 而行为异常的流程活动时间比例关系容易出现离群点。因此计算流程中活动时间的比例关系， 并将其作为特征加入算法是有必要的。</li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h4><blockquote><p><font color="#1E90FF">数据集</font><br>将历史业务流程日志及正在执行流程中的活动执行时间信息作为初始的数据集</p></blockquote><p><font color="#7FFF00">TODO</font><br> 通过目前较为成熟的流程挖掘算法和软件， 如ProM Tools、Disco， 流程模型模拟业务流程获取数据可以简化结构、 缩减活动数量。</p><p><font color="#ff7500">数据初始化：</font><br>待预测流程的活动数量：n<br>多条与待预测执行流程路径一致的历史流程数量：q<br>待预测流程执行时间集：T<br>其中一条流程的活动执行时间序列：<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>T</mi><mi>k</mi></msub><mo>(</mo><mi>k</mi><mo>&#x2208;</mo><mo>[</mo><mn>1</mn><mo>,</mo><mi>q</mi><mo>]</mo><mo>)</mo></math><br>序列中单个活动的执行时间：<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>t</mi><mi>i</mi></msub><mo>(</mo><mi>i</mi><mo>&#x2208;</mo><mo>[</mo><mn>1</mn><mo>,</mo><mi>n</mi><mo>]</mo><mo>)</mo></math></p><p>待预测流程执行时间集：<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>T</mi><mo>=</mo><mfenced close="]" open="["><mrow><msub><mi>T</mi><mn>1</mn></msub><mo>,</mo><msub><mi>T</mi><mn>2</mn></msub><mo>,</mo><mo>&#x22EF;</mo><mo>,</mo><msub><mi>T</mi><mi>k</mi></msub><mo>,</mo><mo>&#x22EF;</mo><mo>,</mo><msub><mi>T</mi><mi>q</mi></msub></mrow></mfenced><mo>,</mo><mi>k</mi><mo>&#x2208;</mo><mo>[</mo><mn>1</mn><mo>,</mo><mi>q</mi><mo>]</mo></math><br>序列k的流程时间：<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>T</mi><mi>k</mi></msub><mo>=</mo><mfenced close="]" open="["><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>,</mo><msub><mi>t</mi><mn>2</mn></msub><mo>,</mo><mo>&#x22EF;</mo><mo>,</mo><msub><mi>t</mi><mi>i</mi></msub><mo>,</mo><mo>&#x22EF;</mo><mo>,</mo><msub><mi>t</mi><mi>n</mi></msub></mrow></mfenced><mo>,</mo><mi>i</mi><mo>&#x2208;</mo><mo>[</mo><mn>1</mn><mo>,</mo><mi>n</mi><mo>]</mo></math></p><h4 id="获得时间比例"><a href="#获得时间比例" class="headerlink" title="获得时间比例"></a>获得时间比例</h4><p><font color="#1E90FF">对长度为 $n$ 的活动执行时间序列<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>T</mi><mi>k</mi></msub></math>，求出长度为 $n-1$ 的时间比例序<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>R</mi><mi>k</mi></msub></math>，记比例数据集为 $R$ </font></p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>R</mi><mo>=</mo><mfenced close="]" open="["><mrow><msub><mi>R</mi><mn>1</mn></msub><mo>,</mo><msub><mi>R</mi><mn>2</mn></msub><mo>,</mo><mo>&#x22EF;</mo><mo>,</mo><msub><mi>R</mi><mi>k</mi></msub><mo>,</mo><mo>&#x22EF;</mo><mo>,</mo><msub><mi>R</mi><mi>q</mi></msub></mrow></mfenced><mo>,</mo><mi>k</mi><mo>&#x2208;</mo><mo>[</mo><mn>1</mn><mo>,</mo><mi>q</mi><mo>]</mo></math><br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>R</mi><mi>k</mi></msub><mo>=</mo><mfenced close="]" open="["><mrow><mfrac><msub><mi>t</mi><mn>1</mn></msub><msub><mi>t</mi><mn>2</mn></msub></mfrac><mo>,</mo><mfrac><msub><mi>t</mi><mn>2</mn></msub><msub><mi>t</mi><mn>3</mn></msub></mfrac><mo>,</mo><mo>&#x22EF;</mo><mo>,</mo><mfrac><msub><mi>t</mi><mi>i</mi></msub><msub><mi>t</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mfrac><mo>,</mo><mo>&#x22EF;</mo><mo>,</mo><mfrac><msub><mi>t</mi><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msub><msub><mi>t</mi><mi>n</mi></msub></mfrac></mrow></mfenced><mo>,</mo><mi>i</mi><mo>&#x2208;</mo><mo>[</mo><mn>1</mn><mo>,</mo><mi>n</mi><mo>-</mo><mn>1</mn><mo>]</mo></math></p><h4 id="对异常流程进行标记"><a href="#对异常流程进行标记" class="headerlink" title="对异常流程进行标记"></a>对异常流程进行标记</h4><ul><li>通过历史流程计算出流程执行时间分布，可以给不同活动设定阈值，来标记超期异常流程</li><li>可以用执行时间拟合建立高斯分布，利用模型参数设立阈值以标记异常（如临界点 $threshold$ <math xmlns="http://www.w3.org/1998/Math/MathML"><mo>=</mo><mi>&#x3BC;</mi><mo>+</mo><mn>2</mn><mo>&#xB7;</mo><mi>&#x3C3;</mi></math>），标记出的异常数据集为<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>t</mi><mi>c</mi><mi>v</mi></math>【time constrain violation 违规时间约束】</li></ul><h4 id="集成业务流程异常预测方法（EnsBPAP）"><a href="#集成业务流程异常预测方法（EnsBPAP）" class="headerlink" title="集成业务流程异常预测方法（EnsBPAP）"></a>集成业务流程异常预测方法（EnsBPAP）</h4><blockquote><p><font color="#9932CC">前提</font><br>将待预测流程的活动执行时间序列记为ｔ，将其时间比例序列记为ｒ， 同数据预处理中得到的历史流程的执行时间,比例数据集和标记出的异常数据集 $T$ , $R$ , $tcv$</p></blockquote><ol><li>将活动执行时间和比例的训练数据集和测试用例数据传入监督学习的分类算法中， 得到超期异常预测结果</li><li>将活动时间比例的训练集和测试用例传入无监督学习异常检测算法， 得到行为异常预测结果</li><li>用两个预测结果访问EnsBPAP分类结果矩阵， 并返回最终的分类结果</li></ol><p><font color="#0000FF">EnsBPAP(t,r,T,R,balance_data)伪代码</font></p><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021531/1622448127881.png" alt="输入输出"></p><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021531/1622448326369.png" alt="步骤函数"></p><ol><li>标记超期异常流程</li><li>标记行为异常【时间比例异常】</li><li>制定EnsBPAP模型【位运算】</li><li>将异常流程通过EnsBPAP模型，获得符合模型的综合分类结果</li></ol><blockquote><p>class： 预测测试过程的综合分类结果</p></blockquote><h4 id="超期异常预测"><a href="#超期异常预测" class="headerlink" title="超期异常预测"></a>超期异常预测</h4><p><font color="#7FFF00">分类器基本模型</font></p><ul><li>逻辑回归算法</li></ul><p><font color="#DC143C">数据存在问题</font></p><ul><li>异常点在整个数据集中的数量远小于正常点的数量【样本不均衡问题】，会导致分类器倾向于把预测样本分为多数类。<h4 id="行为异常检测"><a href="#行为异常检测" class="headerlink" title="行为异常检测"></a>行为异常检测</h4></li></ul><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ol><li>流程的预设期限<font color="#5F9EA0">如何</font> <font color="#696969">在哪</font> 还有 <font color="#BDB76B">设置的标准</font>没有提到</li></ol>]]></content>
    
    
    <summary type="html">挖掘业务流程，结合机器学习进行业务预测分析</summary>
    
    
    
    <category term="paper" scheme="https://merlynr.github.io/categories/paper/"/>
    
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="RPA" scheme="https://merlynr.github.io/tags/RPA/"/>
    
    <category term="machine learning" scheme="https://merlynr.github.io/tags/machine-learning/"/>
    
    <category term="algorithm" scheme="https://merlynr.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>离群点检测</title>
    <link href="https://merlynr.github.io/2021/05/25/%E7%A6%BB%E7%BE%A4%E7%82%B9%E6%A3%80%E6%B5%8B/"/>
    <id>https://merlynr.github.io/2021/05/25/%E7%A6%BB%E7%BE%A4%E7%82%B9%E6%A3%80%E6%B5%8B/</id>
    <published>2021-05-24T16:00:00.000Z</published>
    <updated>2021-05-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p><strong>离群点检测</strong>（<font color=" #009688">异常检测</font>）是找出其行为不同于预期对象的过程，这种对象称为离群点或异常。</p><blockquote><p>离群点和噪声有区别，噪声是观测变量的随机误差和方差，而离群点的产生机制和其他数据的产生机制就有根本的区别,同一批数据产生方式可能不一样。</p></blockquote><p><strong>全局离群点</strong>：通过找到某种合适的偏离度量方式，将离群点检测划为不同的类别；全局离群点是情景离群点的特例，因为考虑整个数据集为一个情境。</p><p><strong>情境离群点</strong>：又称为条件离群点，即在特定条件下它可能是离群点，但是在其他条件下可能又是合理的点。比如夏天的28℃和冬天的28℃等。</p><p><strong>集体离群点</strong>：个体数据可能不是离群点，但是这些对象作为整体显著偏移整个数据集就成为了集体离群点。</p><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021525/1621947763766.png" alt="黑色对象形成集体离群点"></p><h3 id="补充学习"><a href="#补充学习" class="headerlink" title="补充学习"></a>补充学习</h3><blockquote><p>有些模型的表现一直不错，建议优先考虑。对于大数据量和高纬度的数据集，Isolation Forest算法的表现比较好。小数据集上，简单算法KNN和MCD的表现不错。</p></blockquote><p> <font color="#F6C75A">聚类：</font>将物理或抽象对象的集合分成由类似的对象组成的多个类的过程被称为聚类。</p><p><font color="#D87E8D">簇：</font>把数据划分为不同类别，机器学习给这个类别定义一个新的名字—簇。</p><h2 id="离群点检测目前遇到的挑战"><a href="#离群点检测目前遇到的挑战" class="headerlink" title="离群点检测目前遇到的挑战"></a>离群点检测目前遇到的挑战</h2><ul><li>正常数据和离群点的有效建模本身就是个挑战,数据没有标签，无法分清正常数据还是异常数据；或者缺乏异常数据；</li><li>离群点检测高度依赖于应用类型使得不可能开发出通用的离群点检测方法，比如针对性的相似性、距离度量机制等；</li><li>数据质量实际上往往很差，噪声充斥在数据中，影响离群点和正常点之间的差别，缺失的数据也可能“掩盖”住离群点，影响检测到有效性；</li><li>检测离群点的方法需要可解释性；</li></ul><h2 id="离群点检测方法"><a href="#离群点检测方法" class="headerlink" title="离群点检测方法"></a>离群点检测方法</h2><h3 id="监督方法"><a href="#监督方法" class="headerlink" title="监督方法"></a>监督方法</h3><p> <strong>➀训练可识别离群点的分类器</strong></p><p><font color="#009688">困难：</font> 1 .两个类别（正常和离群）的数据量很不平衡，缺乏足够的离群点样本可能会限制所构建分类器的能力；<br>2. 许多应用中，捕获尽可能多的离群点（灵敏度和召回率）比把正常对象误当做离群点更重要。</p><blockquote><p>由于与其他样本相比离群点很稀少，所以离群点检测的监督方法必须注意如何训练和如何解释分类率。</p></blockquote><p><strong>➁One-class model，一分类模型</strong></p><pre><code>考虑到数据集严重不平衡的问题，构建一个仅描述正常类的分类器，不属于正常类的任何样本都被视为离群点。比如SVM决策边界以外的都可以视为离群点。</code></pre><h3 id="无监督方法"><a href="#无监督方法" class="headerlink" title="无监督方法"></a>无监督方法</h3><blockquote><p>正常对象在某种程度上是“聚类”的，正常对象之间具有高度的相似性，但是离群点将远离正常对象的组群。<font color="#72A1C3">但是遇到前文所述的集体离群点时，正常数据是发散的，而离群点反而是聚类的</font>,这种情形下更适合<font color="#A98A2F">监督方法</font>进行检测。无监督方法很容易误标记离群点导致许多真实的离群点逃脱检测。</p></blockquote><p><strong>对于传统的聚类方法，有以下几个问题：</strong></p><ul><li>不属于任何簇的对象可能是噪声，而不是离群点；</li><li>先找出簇再找出离群点的开销很大（离群点数量远少于正常对象）；</li></ul><h3 id="半监督方法"><a href="#半监督方法" class="headerlink" title="半监督方法"></a>半监督方法</h3><p>当有一些被标记的正常对象时，可以先使用它们，与邻近的无标记对象一起训练一个正常的对象模型，使用这个模型检测离群点；但是由于具有标记的数据只有少部分，意味着仅仅基于少量被标记的离群点而构建的离群点模型不大可能是有效的。</p><h3 id="统计方法"><a href="#统计方法" class="headerlink" title="统计方法"></a>统计方法</h3><blockquote><p>假定正常的数据对象由一个统计模型产生，不遵守该模型的数据是离群点。即正常对象出现在该随机模型的高概率区域中，而低概率区域中的对象是离群点</p></blockquote><h4 id="参数方法—壹"><a href="#参数方法—壹" class="headerlink" title="参数方法—壹"></a>参数方法—壹</h4><blockquote><p>基于正态分布的一元离群点检测（仅涉及一个属性或变量的数据）</p></blockquote><ol><li>假定数据由某个正态分布产生，由输入来学习正态分布的参数（μ ，σ）（最大似然估计），通过假设检验的方法，一般认定如果某点距离估计的分布均值超过3σ  ，就被认为是离群点。下面的文章中提到过利用盒图和四分位数据来划分离群点，其原理类似。</li><li>另一种离群点检测方法是Grubb检验（最大标准残差检验），对于数据集中的每个对象x，定义z分数(z-score)为：$z=\frac{|x-\bar{x}|}{s}$ , $\bar{x}$是输入数据的均值，s是标准差。<br>若 $z\geq\frac{N-1}{\sqrt{n}}\sqrt{\frac{t_{a/(2N),N-2}^{2}}{N-2+t_{a/(2N),N-2}^{2}}}$ ,x视为离群点。<br>其中 $t^{2}\alpha/(2N),N-2$ 是显著水平 $\alpha /(2N)$ 下的 $t-$ 分布的值，N是数据集中的对象数。</li></ol><h4 id="参数方法—贰"><a href="#参数方法—贰" class="headerlink" title="参数方法—贰"></a>参数方法—贰</h4><blockquote><p>多元离群点检测<br><font size=1>涉及两个或多个属性或变量的数据称为多元数据。核心思想是把多元离群点检测任务转换成一元离群点检测问题。</font></p></blockquote><ol><li><font color="#032953"><strong>马哈拉诺比斯距离检测多元离群点</strong></font></li></ol><p> 对一个多元数据集，设 $\bar{o}$ 为均值向量，对数据集中的对象 $O$ ，从  $O$ 到 $\bar{o}$ 的马哈拉诺比斯距离为： $$M D i s t(o, \bar{o})=(o-\bar{o})^{T} S^{-1}(o-\bar{o})$$ ,S是协方差矩阵。 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>M</mi><mi>D</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo>(</mo><mi>o</mi><mo>,</mo><mover><mi>O</mi><mo>&#xAF;</mo></mover><mo>)</mo></math>是一元变量，于是可以对它进行Grubb检验，如果<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>M</mi><mi>D</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo>(</mo><mi>o</mi><mo>,</mo><mover><mi>O</mi><mo>&#xAF;</mo></mover><mo>)</mo></math>设定为离群点的阈值，则 $o$ 是为离群点。</p><blockquote><p><font color="#DD7ADF">补充知识：</font><a href="https://blog.zuishuailcq.xyz/2021/05/26/%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5/">协方差矩阵 | 吾辈之人，自当自强不息！</a><br><font color="#2C7D82">协方差矩阵：</font>计算样本不同维度之间的协方差<br><font color="#348A8A">协方差：</font>一般用来刻画两个随机变量的相似程度</p></blockquote><blockquote><p><font color="#F27611">补充知识：</font><strong>欧氏距离</strong>—–又称欧几里得距离<br>m维空间中两个点之间的真实距离<br>例如二维空间的公式：<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3C1;</mi><mo>=</mo><msqrt><msup><mfenced><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>-</mo><msub><mi>x</mi><mn>1</mn></msub></mrow></mfenced><mn>2</mn></msup><mo>+</mo><msup><mfenced><mrow><msub><mi>y</mi><mn>2</mn></msub><mo>-</mo><msub><mi>y</mi><mn>1</mn></msub></mrow></mfenced><mn>2</mn></msup></msqrt></math>，<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3C1;</mi></math> 为点 <math xmlns="http://www.w3.org/1998/Math/MathML"><mfenced><mrow><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><msub><mi>y</mi><mn>2</mn></msub></mrow></mfenced></math>与点 <math xmlns="http://www.w3.org/1998/Math/MathML"><mfenced><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>y</mi><mn>1</mn></msub></mrow></mfenced></math>之间的欧氏距离</p></blockquote><blockquote><p><font color="#4D74F2">补充知识：</font><strong>马哈拉诺比斯距离</strong><br>表示数据的协方差距离，它是一种有效的计算两个未知样本集的相似度的方法。<br><strong>思路</strong>：</p><ul><li>将变量按照主成分进行旋转，消除维度间的相关性</li><li>对向量和分布进行标准化，让各个维度同为标准正态分布</li></ul></blockquote><ol start="2"><li><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>&#x3C7;</mi><mn>2</mn></msup></math><strong>统计量</strong>的多元离群点检测</li></ol><p>  正态分布的假定下，<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>&#x3C7;</mi><mn>2</mn></msup></math>  统计量也可以用来捕获多元离群点，对象 $o$ ，<math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>&#x3C7;</mi><mn>2</mn></msup></math>  统计量是：<br>  <math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>&#x3C7;</mi><mn>2</mn></msup><mo>=</mo><munderover><mo>&#x2211;</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mfrac><msup><mfenced><mrow><msub><mi>o</mi><mi>i</mi></msub><mo>-</mo><msub><mi>E</mi><mi>i</mi></msub></mrow></mfenced><mn>2</mn></msup><msub><mi>E</mi><mi>i</mi></msub></mfrac></math></p><blockquote><p><font color="#6B6B6B">统计量：</font><br>是样本测量的一种<em>属性</em>。类似计算样本的平均值。</p></blockquote><p><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>O</mi><mi>i</mi></msub></math>是$o$在第 $i$ 维上的值，<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>E</mi><mi>i</mi></msub></math>是所有对象在第 $i$ 维上的均值，而n是是维度。如果对象的 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3C7;</mi><mn>2</mn></math>统计量很大，则对象是离群点。</p><ol start="3"><li>混合参数分布检测离群</li></ol><p>  当实际数据很复杂时，假定服从正态分布的话会不太合适，这种情况下假定数据是被混合参数分布产生的。</p><blockquote><p><font color="#1076FF">补充知识：</font><strong>混合分布</strong><br>在概率与统计中，如果我们有一个包含多个随机变量的随机变量集合，再基于该集合生成一个新的随机变量，则该随机变量的分布称为混合分布(mixture distribution)。<br><font color="red">TODO:</font>查阅了<a href="https://blog.csdn.net/tanghonghanhaoli/article/details/90543917">混合分布</a>的三个性质没有理解如何判定离群 </p></blockquote><h4 id="非参数方法—壹"><a href="#非参数方法—壹" class="headerlink" title="非参数方法—壹"></a>非参数方法—壹</h4><p><font color="#DD7ADF">构造直方图</font></p><p>为了构造一个好的直方图，用户必须指定直方图的类型和其他参数（箱数、等宽or等深）。最简单的方法是，如果该对象落入直方图的一个箱中，则该对象被看做正常的，否则被认为是离群点。也可以使用直方图赋予每个对象一个离群点得分，比如对象的离群点得分为该对象落入的箱的容积的倒数。</p><h4 id="非参数方法—贰"><a href="#非参数方法—贰" class="headerlink" title="非参数方法—贰"></a>非参数方法—贰</h4><p><font color="#DD7ADF"><a href="https://blog.csdn.net/pipisorry/article/details/53635895">核密度估计</a></font></p><blockquote><p> <font color="#B22222">补充知识：</font><br> <strong>向量的内积与外积</strong><br> 对于向量a和向量b：<br> <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi><mo>=</mo><mfenced close="]" open="["><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><msub><mi>a</mi><mn>2</mn></msub><mo>,</mo><mo>&#x2026;</mo><mo>&#xB7;</mo><msub><mi>a</mi><mi>n</mi></msub></mrow></mfenced></math><br> <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>b</mi><mo>=</mo><mfenced close="]" open="["><mrow><msub><mi>b</mi><mn>1</mn></msub><mo>,</mo><msub><mi>b</mi><mn>2</mn></msub><mo>,</mo><mo>&#x2026;</mo><mo>,</mo><msub><mi>b</mi><mi>n</mi></msub></mrow></mfenced></math><br> <font color="#00FFFF">内积</font><br> <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi><mo>&#x2219;</mo><mi>b</mi><mo>=</mo><msub><mi>a</mi><mn>1</mn></msub><msub><mi>b</mi><mn>1</mn></msub><mo>+</mo><msub><mi>a</mi><mn>2</mn></msub><msub><mi>b</mi><mn>2</mn></msub><mo>+</mo><mo>&#x2026;</mo><mo>+</mo><msub><mi>a</mi><mi mathvariant="normal">n</mi></msub><msub><mi>b</mi><mi>n</mi></msub></math>，内积的几何意义是可以用来表征【信息在头脑中的呈现方式】或计算两个向量之间的夹角，以及在b向量在a向量方向上的投影。<br><font color="#FF8C00">外积</font><br><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>a</mi><mo>&#xD7;</mo><mi>b</mi><mo>=</mo><mfenced close="|" open="|"><mtable columnalign="left"><mtr><mtd><mi>i</mi></mtd><mtd><mi>j</mi></mtd><mtd><mi>k</mi></mtd></mtr><mtr><mtd><msub><mi>x</mi><mn>1</mn></msub></mtd><mtd><msub><mi>y</mi><mn>1</mn></msub></mtd><mtd><msub><mi>z</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd><msub><mi>x</mi><mn>2</mn></msub></mtd><mtd><msub><mi>y</mi><mn>2</mn></msub></mtd><mtd><msub><mi>z</mi><mn>2</mn></msub></mtd></mtr></mtable></mfenced><mo>=</mo><mfenced><mrow><msub><mi>y</mi><mn>1</mn></msub><msub><mi>z</mi><mn>2</mn></msub><mo>-</mo><msub><mi>y</mi><mn>2</mn></msub><msub><mi>z</mi><mn>1</mn></msub></mrow></mfenced><mi>i</mi><mo>-</mo><mfenced><mrow><msub><mi>x</mi><mn>1</mn></msub><msub><mi>z</mi><mn>2</mn></msub><mo>-</mo><msub><mi>x</mi><mn>2</mn></msub><msub><mi>z</mi><mn>1</mn></msub></mrow></mfenced><mi>j</mi><mo>+</mo><mfenced><mrow><msub><mi>x</mi><mn>1</mn></msub><msub><mi>y</mi><mn>2</mn></msub><mo>-</mo><msub><mi>x</mi><mn>2</mn></msub><msub><mi>y</mi><mn>1</mn></msub></mrow></mfenced><mi>k</mi></math>，外积的结果是一个向量，更为熟知的叫法是法向量，该向量垂直于a和b向量构成的平面。</p></blockquote><p>把每个观测对象看作一个周围区域中的高概率密度指示子，一个点上的概率密度依赖于该点到观测对象的距离，使用核函数对样本点对其邻域的影响建模。核函数K()满足以下两个条件：</p><ol><li><math xmlns="http://www.w3.org/1998/Math/MathML"><msubsup><mo>&#x222B;</mo><mrow><mo>-</mo><mo>&#x221E;</mo></mrow><mo>&#x221E;</mo></msubsup><mi>K</mi><mo>(</mo><mi>u</mi><mo>)</mo><mi>d</mi><mi>u</mi><mo>=</mo><mn>1</mn></math></li><li>对于所有的 $u$ 值，<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi><mo>(</mo><mo>-</mo><mi>u</mi><mo>)</mo><mo>=</mo><mi>K</mi><mo>(</mo><mi>u</mi><mo>)</mo></math></li></ol><p> 一个频繁使用的核函数是标准高斯函数：<br> <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>K</mi><mfenced><mfrac><mrow><mi>x</mi><mo>-</mo><msub><mi>x</mi><mi>i</mi></msub></mrow><mi>h</mi></mfrac></mfenced><mo>=</mo><mfrac><mn>1</mn><msqrt><mn>2</mn><mi>&#x3C0;</mi></msqrt></mfrac><msup><mi>e</mi><mrow><mo>-</mo><mfrac><msup><mfenced><mrow><mi>x</mi><mo>-</mo><msub><mi>x</mi><mi>i</mi></msub></mrow></mfenced><mn>2</mn></msup><mrow><mn>2</mn><msup><mi>h</mi><mn>2</mn></msup></mrow></mfrac></mrow></msup></math></p><blockquote><p><font color="#3B4B6E">补充知识：</font>高斯函数<br>一维形式<br><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mi>a</mi><msup><mi>e</mi><mrow><mo>-</mo><mfrac><mrow><mo>(</mo><mi>x</mi><mo>-</mo><mi>b</mi><msup><mo>)</mo><mn>2</mn></msup></mrow><mrow><mn>2</mn><msup><mi>c</mi><mn>2</mn></msup></mrow></mfrac></mrow></msup></math><br>a是曲线尖峰的高度，b是尖峰中心的坐标，c称为标准方差<br><img src="https://gitee.com/merlynr/img-store/raw/master/2021530/1622339515069.png" alt="高斯函数"></p><p><font color="#DD7ADF">二维高斯核函数</font>常用于高斯模糊Gaussian Blur，在数学领域，主要是用于解决热力方程和扩散方程，以及定义Weiertrass Transform<br><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>f</mi><mo>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>)</mo><mo>=</mo><mi>A</mi><mi>exp</mi><mfenced><mrow><mo>-</mo><mfenced><mrow><mfrac><msup><mfenced><mrow><mi>x</mi><mo>-</mo><msub><mi>x</mi><mi>o</mi></msub></mrow></mfenced><mn>2</mn></msup><mrow><mn>2</mn><msubsup><mi>&#x3C3;</mi><mi>x</mi><mn>2</mn></msubsup></mrow></mfrac><mo>+</mo><mfrac><msup><mfenced><mrow><mi>y</mi><mo>-</mo><msub><mi>y</mi><mi>o</mi></msub></mrow></mfenced><mn>2</mn></msup><mrow><mn>2</mn><msubsup><mi>&#x3C3;</mi><mi>y</mi><mn>2</mn></msubsup></mrow></mfrac></mrow></mfenced></mrow></mfenced></math><br>A是幅值，x。y。是中心点坐标，σx σy是方差，图示如下，A = 1, xo = 0, yo = 0, σx = σy = 1<br><img src="https://gitee.com/merlynr/img-store/raw/master/2021530/1622340032183.png" alt="二维高斯函数"></p></blockquote><p>设 <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>&#x2026;</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub></math> 是随机变量 $f$ 的独立同分布样本，那么概率密度函数的核函数近似为：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mover><mi>f</mi><mo>^</mo></mover><mi>h</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mi>h</mi></mrow></mfrac><munderover><mo>&#x2211;</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mi>K</mi><mfenced><mfrac><mrow><mi>x</mi><mo>-</mo><msub><mi>x</mi><mi>i</mi></msub></mrow><mi>h</mi></mfrac></mfenced></math>,K()是核函数，h是带宽,充当光滑参数</p><p>对于对象 $o$ ， <math xmlns="http://www.w3.org/1998/Math/MathML"><mover><mi>f</mi><mo>^</mo></mover><mo>(</mo><mi>o</mi><mo>)</mo></math> 给出该对象被随机过程中产生的估计概率。如果 <math xmlns="http://www.w3.org/1998/Math/MathML"><mover><mi>f</mi><mo>^</mo></mover><mo>(</mo><mi>o</mi><mo>)</mo></math> 过小，$o$  可能是离群点。</p><h3 id="基于邻近性的方法"><a href="#基于邻近性的方法" class="headerlink" title="基于邻近性的方法"></a>基于邻近性的方法</h3><p>假定一个对象是离群点，如果在特征空间中的最近邻也远离它，即该对象与它的最近邻之间的邻近性显著地偏离数据集中其他对象与它们的近邻之间的邻近性。</p><p>基于邻近性的方法的有效性高度依赖与所使用的邻近性度量，主要有<strong>基于距离</strong>和<strong>基于密度</strong>的离群点检测方法。</p><p><font color="#7FFF00">通俗理解，</font>离群点与近邻点的近邻距离明显大于其它对象与其的近邻的距离。即离群点周边环境明显和其它对象不一样。</p><h4 id="基于距离的离群点检测"><a href="#基于距离的离群点检测" class="headerlink" title="基于距离的离群点检测"></a>基于距离的离群点检测</h4><p>对象给定半径的邻域，如果它的邻域内没有足够多的其他点，则该点被认为是离群点。</p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><mfenced close="||" open="||"><mfenced close="}" open="{"><mrow><msup><mi>o</mi><mo>‘</mo></msup><mo>&#x2223;</mo><mo>dist</mo><mfenced><mrow><mi>o</mi><mo>,</mo><msup><mi>o</mi><mo>‘</mo></msup></mrow></mfenced><mo>&#x2264;</mo><mi>r</mi></mrow></mfenced></mfenced></mrow><mrow><mo>&#x2016;</mo><mi>D</mi><mo>&#x2016;</mo></mrow></mfrac><mo>&#x2264;</mo><mi>&#x3C0;</mi></math></p><p><font color="#228B22">r是距离阈值</font>，<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3C0;</mi></math>  是分数阈值，对象 $o$ 如果满足上面的式子则是一个  离群点。</p><h4 id="基于密度的离群点检测"><a href="#基于密度的离群点检测" class="headerlink" title="基于密度的离群点检测"></a>基于密度的离群点检测</h4><p>基于距离的检测方法从全局考虑数据集，所找到的离群点都是<strong>全局离群点</strong>，但实际上数据结构更复杂，对象<font color="#8FBC8F">可能</font>关于其局部邻域，而<font color="#8FBC8F">不是</font>整个数据分布而视为离群点。</p><p>基于密度的离群点检测方法基本假定为：<strong>非离群点对象周围的密度与其邻域周围的密度类似，而离群点对象周围的密度显著不同于其邻域周围的密度。</strong></p><p><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>N</mi><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo><mo>=</mo><mfenced close="}" open="{"><mrow><msup><mi>o</mi><mo>‘</mo></msup><mo>&#x2223;</mo><msup><mi>o</mi><mo>‘</mo></msup><mo>&#x2208;</mo><mi>D</mi><mo>,</mo><mo>dist</mo><mfenced><mrow><mi>o</mi><mo>,</mo><msup><mi>o</mi><mo>‘</mo></msup></mrow></mfenced><mo>&#x2264;</mo><msub><mo>dist</mo><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo></mrow></mfenced></math></p><p>D为数据集，<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mo>dist</mo><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo></math>  是对象o第k个近邻的对象之间的距离，<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>N</mi><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo></math>  是所有在<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mo>dist</mo><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo></math> 之内的对象集。可以使用 <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>N</mi><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo></math> 中的对象到o的平均距离作为局部密度的度量，但是为了避免比如有非常近的近邻使得距离度量统计产生波动，需要加上光滑效果：<br>$reachdist$<math xmlns="http://www.w3.org/1998/Math/MathML"><mmultiscripts><mfenced><mrow><mi>o</mi><mo>&#x2190;</mo><msup><mi>o</mi><mo>‘</mo></msup></mrow></mfenced><mprescripts/><mi>k</mi><none/></mmultiscripts><mo>=</mo><mi>max</mi><mfenced close="}" open="{"><mrow><msub><mo>dist</mo><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo><mo>,</mo><mo>dist</mo><mfenced><mrow><mi>o</mi><mo>,</mo><msup><mi>o</mi><mo>‘</mo></msup></mrow></mfenced></mrow></mfenced></math><br>k是用户指定参数，控制光滑效果。对象o的局部密度为：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>l</mi><mi>r</mi><msub><mi>d</mi><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo><mo>=</mo><mfrac><mfenced close="||" open="||"><mrow><msub><mi>N</mi><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo></mrow></mfenced><mrow><msub><mo>&#x2211;</mo><mrow><msup><mi>o</mi><mo>‘</mo></msup><mo>&#x2208;</mo><msub><mi>N</mi><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo></mrow></msub><msub><mtext>&#xA0;reachdist&#xA0;</mtext><mi>k</mi></msub><mfenced><mrow><msup><mi>o</mi><mo>‘</mo></msup><mo>&#x2190;</mo><mi>o</mi></mrow></mfenced></mrow></mfrac></math><br>o的局部离群点因子为：<br><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>L</mi><mi>O</mi><msub><mi>F</mi><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo><mo>=</mo><mfrac><mrow><msub><mo>&#x2211;</mo><mrow><msup><mi>o</mi><mo>‘</mo></msup><mo>&#x2208;</mo><msub><mi>N</mi><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo></mrow></msub><mfrac><mrow><msub><mo>lrd</mo><mi>k</mi></msub><mfenced><msup><mi>o</mi><mo>‘</mo></msup></mfenced></mrow><mrow><msub><mo>lrd</mo><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo></mrow></mfrac></mrow><mfenced close="||" open="||"><mrow><msub><mi>N</mi><mi>k</mi></msub><mo>(</mo><mi>o</mi><mo>)</mo></mrow></mfenced></mfrac></math><br>局部离群点因子是o的可达密度与o的k-最近邻可达密度之比的平均值。对象o的局部可达密度越低，并且o的k-最近邻局部可达密度越高，LOF值越高。</p><p><font color="#B8860B">LOF 的思想：</font><br>通过比较每个点 p 和其邻域点的密度来判断该点是否为异常点，如果点 p 的密度越低，越可能被认定是异常点。至于这个密度，是通过点之间的距离来计算的，点之间距离越远，密度越低，距离越近，密度越高，而且这里的密度不是基于全局数据，而是基于局部数据。</p><h3 id="基于聚类的方法"><a href="#基于聚类的方法" class="headerlink" title="基于聚类的方法"></a>基于聚类的方法</h3><p>假定<font color="#556B2F">正常数据</font>对象属于大的、稠密的簇、而<font color="#556B2F">离群点</font>属于小或稀疏的簇，或者不属于任何簇。直截了当的采用聚类方法用于离群点检测开销会很大，不能很好地扩展到大数据集上。</p><ol><li>将离群点检测为不属于任何簇的对象</li><li>最近簇距离的离群点检测</li></ol><blockquote><p>假设o到最近的簇中心为 <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>c</mi><mi>o</mi></msub></math> ,则o与 <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>c</mi><mi>o</mi></msub></math> 之间的距离为 <math xmlns="http://www.w3.org/1998/Math/MathML"><mo>dist</mo><mfenced><mrow><mi>o</mi><mo>,</mo><msub><mi>c</mi><mi>o</mi></msub></mrow></mfenced></math> ， <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>c</mi><mi>o</mi></msub></math> 与指派到 <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>c</mi><mi>o</mi></msub></math> 这个簇中的对象之间的平均距离为 <math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>l</mi><msub><mi>c</mi><mi>o</mi></msub></msub></math> ，比率 <math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mrow><mo>dist</mo><mfenced><mrow><mi>o</mi><mo>,</mo><msub><mi>c</mi><mi>o</mi></msub></mrow></mfenced></mrow><msub><mi>l</mi><msub><mi>c</mi><mi>o</mi></msub></msub></mfrac></math> 度量 <math xmlns="http://www.w3.org/1998/Math/MathML"><mo>dist</mo><mfenced><mrow><mi>o</mi><mo>,</mo><msub><mi>c</mi><mi>o</mi></msub></mrow></mfenced></math> 与平均值的差异程度。</p></blockquote><ol start="3"><li>识别小簇或稀疏簇</li></ol><blockquote><p>先是找出数据集中的簇，并把它们按照大小降序排列，假定大部分数据点都不是离群点。它使用一个参数<math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3B1;</mi><mo>(</mo><mn>0</mn><mo>&#x2264;</mo><mi>&#x3B1;</mi><mo>&#x2264;</mo><mn>1</mn><mo>)</mo></math>  区别大小簇。任何至少包含数据集中 <math xmlns="http://www.w3.org/1998/Math/MathML"><mi>&#x3B1;</mi><mo>%</mo></math> 数据点的簇都被视为大簇，其余为小簇。然后对每个数据点赋予基于簇的局部离群点因子(CBLOF)。对于属于大簇的点，它的CBLOF是簇的大小与该点与簇的相似性的乘积。对于小簇的点，其CBLOF用小簇的大小和该点与最近的大簇的相似性乘积计算。<br>CBLOF代表点属于簇的概率，值越大，点与簇越相似。远离任何大簇的小簇被看作离群点组成，并且具有最低CBLOF值的点怀疑为离群点。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>LOF类的算法适用于局部区域空间问题，对于完整区域空间，KNN和Iforest更好。</li><li>KNN每次运行需要遍历所有数据，所以效率比较低，如果效率要求比较高，用聚类方法更好。</li><li>传统机器学习算法中Iforest、KNN和OCSVM表现较好，基于深度学习的算法准确率在论文中更好！</li><li>对于不同种类的数据，没有哪一种算法是最好的，HBOS算法在某些数据集上的表现非常好，且运算速度很快。</li><li>当数据特征数很多时，如400个特征，只有KNN表现还不错，Iforest表现也不好，因为特征选取的随机性，可能无法覆盖足够多的特征（不绝对）。</li><li>ABOD综合效果最差，尽量不要用。</li></ol>]]></content>
    
    
    <summary type="html">数据挖掘--离群点检测算法的学习</summary>
    
    
    
    <category term="algorithm" scheme="https://merlynr.github.io/categories/algorithm/"/>
    
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="machine learning" scheme="https://merlynr.github.io/tags/machine-learning/"/>
    
    <category term="algorithm" scheme="https://merlynr.github.io/tags/algorithm/"/>
    
    <category term="data mining" scheme="https://merlynr.github.io/tags/data-mining/"/>
    
  </entry>
  
  <entry>
    <title>2021-05-24【Week】</title>
    <link href="https://merlynr.github.io/2021/05/24/2021-05-24%E3%80%90Week%E3%80%91/"/>
    <id>https://merlynr.github.io/2021/05/24/2021-05-24%E3%80%90Week%E3%80%91/</id>
    <published>2021-05-23T16:00:00.000Z</published>
    <updated>2021-05-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本周安排"><a href="#本周安排" class="headerlink" title="本周安排"></a>本周安排</h2><ul><li><input disabled="" type="checkbox"> 重新梳理研究方向</li><li><input disabled="" type="checkbox"> 寻找并阅读相关文章两篇</li><li><input disabled="" type="checkbox"> 坚持英语学习20mis/everyday</li><li><input disabled="" type="checkbox"> 沙盒搭建</li></ul><h2 id="完成情况"><a href="#完成情况" class="headerlink" title="完成情况"></a>完成情况</h2><ol><li>将docker有关的操作过了一遍</li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;本周安排&quot;&gt;&lt;a href=&quot;#本周安排&quot; class=&quot;headerlink&quot; title=&quot;本周安排&quot;&gt;&lt;/a&gt;本周安排&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; 重新梳理研究方向&lt;/li&gt;
&lt;li&gt;&lt;i</summary>
      
    
    
    
    <category term="weekly report" scheme="https://merlynr.github.io/categories/weekly-report/"/>
    
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="weekly" scheme="https://merlynr.github.io/tags/weekly/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>2021-05-15【Week】</title>
    <link href="https://merlynr.github.io/2021/05/19/2021-05-15%E3%80%90Week%E3%80%91/"/>
    <id>https://merlynr.github.io/2021/05/19/2021-05-15%E3%80%90Week%E3%80%91/</id>
    <published>2021-05-18T16:00:00.000Z</published>
    <updated>2021-05-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本周安排"><a href="#本周安排" class="headerlink" title="本周安排"></a>本周安排</h3><ul><li><input disabled="" type="checkbox"> 源码分析</li><li><input disabled="" type="checkbox"> 预开题准备</li><li><input disabled="" type="checkbox"> 重新整理并寻找合适的研究点</li></ul><h3 id="任务完成情况"><a href="#任务完成情况" class="headerlink" title="任务完成情况"></a>任务完成情况</h3><ol><li>源码分析已经完成，tagui的源码的难点主要是语言多，但是其中逻辑不是很难</li><li>这次预开题，我是比较认真准备的，当时讲的时候人比较多，可能比较着急哇，我主要为了解决RPA中可并发执行任务的功能，这块的难点就是资源分配的问题，所以涉及了大量资源分配的研究，目前国内外RPA这方面都比较淡化，没有很好的解决方式，所以我感觉还是可以的：）</li><li>现在在看老师给发的文档，大部分我也看过了，里面的点太笼统，面太大，当时和老师交流后，重新理解了一下，是研究机器学习在业务流程中处理文档，表格，但是目前就RPA里面来说，自动获取文件中信息处理的比较好，各个公司都没有在这块上投入更多资源</li></ol><h3 id="汇总文件补充"><a href="#汇总文件补充" class="headerlink" title="汇总文件补充"></a>汇总文件补充</h3><blockquote><p>平时学习时，总结都是单独的，所以这块就引用上周写的汇总了</p></blockquote><ol><li>tagui源码分析</li></ol><p><img src="./attachments/TagUI%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%8F%8A%E5%88%86%E6%9E%90.pdf" alt="TagUI源码阅读及分析"></p><ol start="2"><li>预开题PPT</li></ol><p><img src="./attachments/RPA%E5%8A%A8%E6%80%81%E6%84%9F%E7%9F%A5%E5%88%86%E9%85%8D%E4%B8%9A%E5%8A%A1%E8%B5%84%E6%BA%90%E7%9A%84%E7%A0%94%E7%A9%B6%E4%B8%8E%E5%BA%94%E7%94%A8.pptx" alt="RPA动态感知分配业务资源的研究与应用"></p><ol start="3"><li>重新整理—未完成</li></ol><p><img src="./attachments/RPA+AI.pdf" alt="RPA+AI"></p>]]></content>
    
    
    <summary type="html">每周安排</summary>
    
    
    
    <category term="weekly report" scheme="https://merlynr.github.io/categories/weekly-report/"/>
    
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="report" scheme="https://merlynr.github.io/tags/report/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="weekly" scheme="https://merlynr.github.io/tags/weekly/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>RPA+AI</title>
    <link href="https://merlynr.github.io/2021/05/17/RPA+AI/"/>
    <id>https://merlynr.github.io/2021/05/17/RPA+AI/</id>
    <published>2021-05-16T16:00:00.000Z</published>
    <updated>2021-05-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="https://developer.aliyun.com/group/rpa?spm=a2c6h.12873639.0.0.65b05d65mS6OlC#/?_k=agnoe0">阿里云RPA社区</a></p><p><a href="https://zhuanlan.zhihu.com/p/59034887?utm_oi=786717341600858112">阿里云RPA（机器人流程自动化）系列</a></p><p><a href="https://www.yuque.com/aliyun_rpa">阿里云RPA文档</a></p><p><a href="https://github.com/rpabotsworld/awesome-rpa">资源</a></p><h2 id="阅读记录"><a href="#阅读记录" class="headerlink" title="阅读记录"></a>阅读记录</h2><h3 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h3><h4 id="阿里云RPA系列"><a href="#阿里云RPA系列" class="headerlink" title="阿里云RPA系列"></a>阿里云RPA系列</h4><ol><li>文件信息的处理–提取和处理结构和半结构化数据</li><li>异常处理–宕机、流程回滚、中断后的流程接续等问题</li><li>业务流程从明确化变为高适配的—智能处理【制定与运行过程中】</li><li>各类场景–大量重复【基本配置通用性高】、可贴合各类场景【规则灵活，外附组件可灵活配置】</li></ol><h4 id="S公司智能财务机器人共享中心建设与实践"><a href="#S公司智能财务机器人共享中心建设与实践" class="headerlink" title="S公司智能财务机器人共享中心建设与实践"></a>S公司智能财务机器人共享中心建设与实践</h4><p><a href="https://m.hanspub.org/journal/paper/34237">URL</a></p><ol><li>分布式部署时，对于资源无法实时有效判断其是否有效可用</li><li>将robot集中到资源池中，供全公司使用，打破单元机器人的壁垒—无法有效的共享数据，但是安全受到了极大威胁</li></ol><h4 id="一种基于RPA机器人共享中心的自动审批的方法【专利】"><a href="#一种基于RPA机器人共享中心的自动审批的方法【专利】" class="headerlink" title="一种基于RPA机器人共享中心的自动审批的方法【专利】"></a>一种基于RPA机器人共享中心的自动审批的方法【专利】</h4><p><a href="http://www10.drugfuture.com/pdfview/generic/web/viewer.html?file=/cnpat/package/%E5%8F%91%E6%98%8E%E4%B8%93%E5%88%A9%E7%94%B3%E8%AF%B7%E8%AF%B4%E6%98%8E%E4%B9%A6CN201911335237.4.pdf">PDF</a></p><ol><li>没有实际创新点，就是为用户提供了访问权限，根据用户自己提交的内容，进行过滤分类，然后由robot进行访问对应的资源进行处理，专利只是讲了研究内容，具体算法和实践没有提到，所以它所涉及到的对机器人共享中心进行分级调度没有表现出来。</li></ol><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><blockquote><p>阿里云版本迭代</p></blockquote><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021517/1621238642819.png" alt="阿里云版本迭代方案"></p><h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><ol><li>流程处理未知问题的智能化</li><li>中间通信安全</li><li>重新定义RPA，目前RPA，只是一个外接的控制工具，而不能替代人工</li><li>==* #F44336==挖掘业务流程，结合机器学习进行业务预测</li><li></li></ol><h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><ol><li>无数据比对，无证明方式，用数据证明有效改进</li></ol><p><a href="https://wap.cnki.net/touch/web/Dissertation/Article/10013-1019047248.nh.html">https://wap.cnki.net/touch/web/Dissertation/Article/10013-1019047248.nh.html</a></p><p><a href="https://www.touqikan.com/jsjj/660421.html">https://www.touqikan.com/jsjj/660421.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;相关文章&quot;&gt;&lt;a href=&quot;#相关文章&quot; class=&quot;headerlink&quot; title=&quot;相关文章&quot;&gt;&lt;/a&gt;相关文章&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://developer.aliyun.com/group/rpa?spm=a2c6h.1287</summary>
      
    
    
    
    <category term="RPA" scheme="https://merlynr.github.io/categories/RPA/"/>
    
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="RPA" scheme="https://merlynr.github.io/tags/RPA/"/>
    
    <category term="machine learning" scheme="https://merlynr.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>机器学习--吴恩达</title>
    <link href="https://merlynr.github.io/2021/05/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0--%E5%90%B4%E6%81%A9%E8%BE%BE/"/>
    <id>https://merlynr.github.io/2021/05/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0--%E5%90%B4%E6%81%A9%E8%BE%BE/</id>
    <published>2021-05-16T16:00:00.000Z</published>
    <updated>2021-05-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>监督学习—因子和结果都给出，让机器学习判断<br>无监督学习–无规则学习 【聚类属于无监督】</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;监督学习—因子和结果都给出，让机器学习判断&lt;br&gt;无监督学习–无规则学习 【聚类属于无监督】&lt;/p&gt;
</summary>
      
    
    
    
    <category term="machine learning" scheme="https://merlynr.github.io/categories/machine-learning/"/>
    
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="machine learning" scheme="https://merlynr.github.io/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>Nicholas Burns</title>
    <link href="https://merlynr.github.io/2021/05/06/Nicholas%20Burns/"/>
    <id>https://merlynr.github.io/2021/05/06/Nicholas%20Burns/</id>
    <published>2021-05-05T16:00:00.000Z</published>
    <updated>2021-05-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>身份：</strong><br>•    罗伊和芭芭拉·古德曼（Roy and Barbara Goodman）哈佛大学肯尼迪学校外交与国际关系实践家庭教授<br>•    Belfer Center董事会成员<br>•    外交项目的未来教席<br>•    欧洲与跨大西洋关系项目教席<br>•    中东倡议联盟会员<br>•    美国国务秘书项目主任</p><p><strong>个人履历见附件</strong></p><p><img src="./attachments/RNB_Bio_Full_1.pdf" alt="RNB_Bio_Full_1"></p><p><strong>联系方式：</strong></p><ul><li>twitter： @rnicholasburns</li><li>phone： 617-495-2495</li><li>邮箱：<a href="mailto:&#x6e;&#105;&#x63;&#x68;&#111;&#x6c;&#x61;&#x73;&#95;&#98;&#117;&#x72;&#x6e;&#x73;&#x40;&#x68;&#x6b;&#x73;&#x2e;&#x68;&#97;&#114;&#118;&#97;&#114;&#x64;&#x2e;&#101;&#x64;&#x75;">&#x6e;&#105;&#x63;&#x68;&#111;&#x6c;&#x61;&#x73;&#95;&#98;&#117;&#x72;&#x6e;&#x73;&#x40;&#x68;&#x6b;&#x73;&#x2e;&#x68;&#97;&#114;&#118;&#97;&#114;&#x64;&#x2e;&#101;&#x64;&#x75;</a></li></ul><p><strong>助理信息：</strong></p><ul><li>艾莉森·希格斯（Alison Hillegeist）</li><li>电邮：<a href="mailto:&#97;&#108;&#x69;&#115;&#x6f;&#x6e;&#x5f;&#104;&#105;&#108;&#108;&#x65;&#103;&#x65;&#105;&#115;&#x74;&#64;&#x68;&#x6b;&#115;&#x2e;&#x68;&#97;&#x72;&#x76;&#x61;&#x72;&#x64;&#x2e;&#x65;&#100;&#117;">&#97;&#108;&#x69;&#115;&#x6f;&#x6e;&#x5f;&#104;&#105;&#108;&#108;&#x65;&#103;&#x65;&#105;&#115;&#x74;&#64;&#x68;&#x6b;&#115;&#x2e;&#x68;&#97;&#x72;&#x76;&#x61;&#x72;&#x64;&#x2e;&#x65;&#100;&#117;</a></li><li>电话：617-495-2495</li><li>Mailing Address: John F. Kennedy School of Government、79 JFK St.、Cambridge, Massachusetts</li></ul><p><strong>家庭：</strong><br>妻子伊丽莎白·贝利（Elizabeth A. Baylies）育有三个女儿：莎拉（Sarah），伊丽莎白（Elizabeth）和卡罗琳（Caroline）</p><p><a href="https://www.youtube.com/watch?v=BloYsnYLxhM&t=42s">信息来源-1</a></p><ul><li>Nicholas Burns与妻子贝利在巴黎美国大学（American University of Paris）在1982年相识并相爱 </li><li>莎拉（Sarah）: 2017.05 毕业于巴黎美国大学（AUP）</li></ul><p><strong>官方个人网站：</strong> <a href="https://www.belfercenter.org/person/nicholas-burns">https://www.belfercenter.org/person/nicholas-burns</a></p><blockquote><p>亲属</p></blockquote><p>侄子：  Ben Hutchins【 command of Marine Air Group 13 in Yuma,2019.08】（侄子本·哈钦斯上校（Ben Hutchins上校）为亚利桑那州尤马市的第13航空集团负责，现在指挥F-35和“ rier”式战斗机）</p><p>堂兄： 鲍勃·肯尼迪【Bob Kennedy  led the historic Mechanics Hall in Worcester for 12 years,2006-2018】<br><img src="https://gitee.com/merlynr/img-store/raw/master/202156/Dn-k1W_XoAEdMqu.jfif" alt="Dn-k1W_XoAEdMqu"></p><blockquote><p>哈佛</p></blockquote><p>助教： Philip Balson【哈佛大学，2019毕业】<br>菲利普·巴尔森</p><p><img src="https://gitee.com/merlynr/img-store/raw/master/202156/D1vTtnUWsAYtUFT.jfif" alt="菲利普·巴尔森"></p><p>Vince Lowney【研究助理文斯·洛尼2018.05毕业于哈佛，并于<strong>7月就任美国外交部</strong>】</p><p><img src="https://gitee.com/merlynr/img-store/raw/master/202156/Dd_uNA6W4AAsCyp.jfif" alt="Dd_uNA6W4AAsCyp"></p><p>Aditi Kumar 和 Chris Mirasola 2018.05毕业于哈佛</p><p><img src="https://gitee.com/merlynr/img-store/raw/master/202156/Dd-jdveXkAAu3TU.jfif" alt="Dd-jdveXkAAu3TU"></p><p>泰莎·亨利（Tessa Henry）和但丁·托波（Dante Toppo）2017.05毕业于哈佛</p><p><img src="https://gitee.com/merlynr/img-store/raw/master/202156/DAsbrBBXUAQoJcb.jfif" alt="DAsbrBBXUAQoJcb"></p><blockquote><p>组织@RedSox  –棒球俱乐部，没找到与之有关的报道</p></blockquote>]]></content>
    
    
    <summary type="html">社工</summary>
    
    
    
    <category term="people" scheme="https://merlynr.github.io/categories/people/"/>
    
    
    <category term="security" scheme="https://merlynr.github.io/tags/security/"/>
    
    <category term="people" scheme="https://merlynr.github.io/tags/people/"/>
    
  </entry>
  
  <entry>
    <title>TagUI源码阅读及分析</title>
    <link href="https://merlynr.github.io/2021/05/06/TagUI%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%8F%8A%E5%88%86%E6%9E%90/"/>
    <id>https://merlynr.github.io/2021/05/06/TagUI%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%8F%8A%E5%88%86%E6%9E%90/</id>
    <published>2021-05-05T16:00:00.000Z</published>
    <updated>2021-05-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>idea：</p><ol><li>RPA进程与AI的融合，非BPA那种与业务进行结合</li></ol><h3 id="tagui运行背后的技术支持"><a href="#tagui运行背后的技术支持" class="headerlink" title="tagui运行背后的技术支持"></a>tagui运行背后的技术支持</h3><p><img src="https://gitee.com/merlynr/img-store/raw/master/202156/1620314243708.png" alt="技术支持"></p><ol><li>Automation Flow:作为一种flow 编辑工具，集成在tagui中，允许TagUi可以通过本地文件，在线文件甚至url获取业务流程；</li></ol><ul><li>同时可以通过命令，图表，url，API，email等方式传入参数</li></ul><ol start="3"><li>Chrome Extension 可以通过类似录视频的方式记录用户行为并创建业务流程</li><li>R&amp;Python 提供机器学习模块</li><li>Sikuli 图像识别处理</li><li>CasperJS测试集成工具</li></ol><h3 id="关键技术组成"><a href="#关键技术组成" class="headerlink" title="关键技术组成"></a>关键技术组成</h3><ul><li>SikuliX 用于图像标记、追踪功能</li><li>phantomJs 是一种轻量级脚本语言（环境简单）</li><li>casperjs中基于PhantomJS和SlimerJS的导航脚本和测试工具，包函了对于一些对于网页的基本操作的工具</li><li>SlimerJS与phantomjs类似，互相补充</li></ul><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><ul><li>end_process: 通过扫描进程，按顺序杀死进程比Ctrl+C更加安全可靠</li><li>erina:==与tagui——helper有关，暂时无法看懂 #009688==</li><li>sleep: 补充win10环境中对于进程延迟的控制</li><li>tagui：TagUI接受脚本和参数</li><li>tagui_chrome: 用于连接chrome，通过控制浏览器发送和接收数据</li><li>tagui_crontab: 运行tagui服务端tagui_service</li><li>tagui_footer: 输出当前网站的url和title</li><li>tagui_global: ==暂时不懂 #009688==</li><li>tagui_header: ==作为一个工具包 #009688==</li></ul><h3 id="功能实现详细阐述"><a href="#功能实现详细阐述" class="headerlink" title="功能实现详细阐述"></a>功能实现详细阐述</h3><ol><li>监控对应任务进程进行杀死【php,chrome,sikuli,python,r,tagui】</li><li>sss</li><li>在Windows环境中无法进程设置延时，所以通过ping.exe补充功能</li><li>tagui框架入口源码交易理解，不做详细分析</li><li>tagui_chrome主要是依赖Textalk实现与chrome并发通信,同时它集成了Sikuli，可以通过图像识别实现业务流程</li><li>通过监控服务端状态，运行或者重复运行tagui_service</li><li>利用casperJs抓取当前脚本的url和title</li><li>sss</li><li>sss</li></ol><h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><p><a href="https://zhuanlan.zhihu.com/p/366304958">https://zhuanlan.zhihu.com/p/366304958</a><br><a href="https://github.com/kensoh/TagUI/tree/before_aisg">https://github.com/kensoh/TagUI/tree/before_aisg</a></p><h4 id="shell语言规范"><a href="#shell语言规范" class="headerlink" title="shell语言规范"></a>shell语言规范</h4><p><a href="https://www.cnblogs.com/zrmw/p/9625727.html">https://www.cnblogs.com/zrmw/p/9625727.html</a></p><p><a href="https://blog.csdn.net/weixin_37766087/article/details/99974385">https://blog.csdn.net/weixin_37766087/article/details/99974385</a></p><h4 id="curl工具"><a href="#curl工具" class="headerlink" title="curl工具"></a>curl工具</h4><p><a href="https://www.ruanyifeng.com/blog/2019/09/curl-reference.html">https://www.ruanyifeng.com/blog/2019/09/curl-reference.html</a></p><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p><a href="https://blog.csdn.net/shenhuan1104/article/details/75852822">https://blog.csdn.net/shenhuan1104/article/details/75852822</a></p><p>grep -iq 404 ，匹配到404，则返回1；反之</p><h4 id="业务流程模型（BPMN）"><a href="#业务流程模型（BPMN）" class="headerlink" title="业务流程模型（BPMN）"></a>业务流程模型（BPMN）</h4><h4 id="流程引擎"><a href="#流程引擎" class="headerlink" title="流程引擎"></a>流程引擎</h4><p>CasperJS + PhantomJS==》Puppeteer + Node.js引擎</p><p><a href="https://blog.csdn.net/qq_38941937/article/details/110296665">https://blog.csdn.net/qq_38941937/article/details/110296665</a></p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol><li>流式无并行</li></ol><h4 id="开题失败—题目比较无实际意义"><a href="#开题失败—题目比较无实际意义" class="headerlink" title="开题失败—题目比较无实际意义"></a>开题失败—题目比较无实际意义</h4><p><img src="./attachments/RPA%E5%8A%A8%E6%80%81%E6%84%9F%E7%9F%A5%E5%88%86%E9%85%8D%E4%B8%9A%E5%8A%A1%E8%B5%84%E6%BA%90%E7%9A%84%E7%A0%94%E7%A9%B6%E4%B8%8E%E5%BA%94%E7%94%A8.pptx" alt="RPA动态感知分配业务资源的研究与应用"></p>]]></content>
    
    
    <summary type="html">Tagui源码阅读</summary>
    
    
    
    <category term="FrameWork" scheme="https://merlynr.github.io/categories/FrameWork/"/>
    
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="RPA" scheme="https://merlynr.github.io/tags/RPA/"/>
    
    <category term="code" scheme="https://merlynr.github.io/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>2021-04-12【Week】</title>
    <link href="https://merlynr.github.io/2021/04/12/2021-04-12%E3%80%90Week%E3%80%91/"/>
    <id>https://merlynr.github.io/2021/04/12/2021-04-12%E3%80%90Week%E3%80%91/</id>
    <published>2021-04-11T16:00:00.000Z</published>
    <updated>2021-05-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本周安排"><a href="#本周安排" class="headerlink" title="本周安排"></a>本周安排</h2><ul><li><input disabled="" type="checkbox"> MIT6.003要听四节课程</li><li><input checked="" disabled="" type="checkbox"> 阅读并总结论文</li></ul><blockquote><p>Automated Discovery of Data Transformations for Robotic Process Automation</p></blockquote><ul><li><input checked="" disabled="" type="checkbox"> 阅读 “Robotic Process Automation (RPA) and Security ”制定一份RPA系统配置计划书</li><li><input checked="" disabled="" type="checkbox"> 完成RPA总结</li><li><input disabled="" type="checkbox"> 搭建实验室论坛</li><li><input disabled="" type="checkbox"> 完成小论文框架</li></ul><p><strong>后期补充</strong></p><ul><li><input checked="" disabled="" type="checkbox"> 帮涛总完成数据库整理</li><li><input checked="" disabled="" type="checkbox"> 确定基本RPA系统的组成</li></ul><h2 id="完成情况"><a href="#完成情况" class="headerlink" title="完成情况"></a>完成情况</h2><p><strong>任务完成</strong></p><ol><li>MIT6.003只听完第一节课，英语讲需要字幕反复听；</li><li>两篇论文，第一篇是关于RPA在进行文档操作过程中数据转换的改进，这篇还没有细读，后面细读一下、第二篇是关于RPA可能存在的问题，只是一篇综述，没有实际建议</li><li>RPA总结也初步完成，包括给那几个本科生讲了一下，就当时情况看，他们确实没有多少了解，几位同学可能还需要一些项目培养一下编码能力，可能需要更多努力来完成比赛，同时对于比赛题目的确定也需要多多了解RPA的应用场景</li><li>实验室论坛这块准备先让新来的师弟试试呀，和他交流过，他对于网络这块比较擅长，但是对于服务器这块比较欠缺，目前他和邹瑞学习，正好可以锻炼一下，如果后期没有完成，我再完成</li><li>目前研究点基本明确，只是缺少一个对于RPA研究下去信心，资料少，人少，学习内容多，工程大，确实需要先把UiPath搭建起来，并研究通了才能有信息继续研究下去</li><li>小论文这块想的是，本来学硕要求变难了，在平时学习过程中就开始填充知识，尽可能的跟上戴师兄和陈剑秋师兄的脚步</li><li>周五上午的数据整理初步完成，当时整理只是整理了部分，涛总也只是催了几个数据库的整理，后续情况等下次涛总安排吧</li><li>周六周日的时间，调研了一下UiPath的搭建，确定了基本的需求和流程，准备下周准备资源并进行搭建</li></ol><p><strong>学习方面</strong></p><blockquote><p>主要精力集中在RPA的总结上了，通过梳理几个大型公司的RPA产品，确定了目前比较热门以及将会被推广的产品有点：</p></blockquote><ol><li>对于屏幕抓取的智能解决方案，通过AI自我修复流程，极低的降低了业务流程因因素抓取失败或因被其它相近元素干扰导致流程作业失败的机率</li><li>为用户提供一个可以用户可以自己训练AI的场景，让用户可以根据自己实际生产需求，训练出更符合自身的AI</li><li>视频录制业务流程，传统的录制由于对于元素的获取容易受到旁边元素干扰，而且对于未知问题处理能力极差，所有需要专门RPA开发员的，但是目前有个别公司推出了一个图像识别算法，大体意思是通过扫描页面元素树确定鼠标触碰元素，几乎达到无失误识别，同时加上AI修正流程功能，录制视频来创建业务流程的目的已经可以达到了。</li><li>还有一点是比较容易忽略的同时是很实际的，对于RPA的部署，本身RPA对于资源的消耗是比较大的，但是却是弹性的，所以比较难以控制RPA部署规模，有个别公司也提出了解决方案，就是，算法，bot，已经中台控制都是分开，分规模，分类别可选择的进行部署。</li></ol><p> <strong>论文方面</strong></p><ol><li>RPA相关的论文，除了一些综述已经找不到其它有价值的了，下一步可能更多去一些公司的论坛进行查看了</li><li>目前有两个点，一个是，通过大量阅读和对于各个公司的观察，发现他们的重心都放在与AI的结合，扩展使用场景，却回避了RPA安全的严重缺陷，可能他们的场景是公司内网吧，所以第一个研究点就是RPA中的安全传输或者RPA中bot的数字认证；第二个是大点，还未确定可能与第一点，就是寻找一个应用场景，RPA需要与场景结合，通用性太高就容易导致研究</li><li>为RPA场景做准备，会阅读一些与人工智能相关的论文</li></ol><h2 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h2><ol><li>学习资料已经只剩下框架的官方文档了，国内外的论文可以查到的都是一些综述了，后期只能查阅一些一些公司的讨论</li><li>对于UiPath的搭建进行了初步了解，RPA框架本身存在的问题就是无法容器化，这也是一个研究点，所以如果公司没用空的服务器，我只能在本地虚拟金进行尝试了，我今天在阿里云买了一个两核4G的服务器上进行搭建，发现内存不够，但是扩容需要钱太多了，就放弃了，下一步就在本地搭建RPA只能在本地进行尝试</li></ol><h2 id="后期安排"><a href="#后期安排" class="headerlink" title="后期安排"></a>后期安排</h2><ul><li><input disabled="" type="checkbox"> 提出一个较为可操作的部署方案，并在本地进行尝试并总结</li><li><input disabled="" type="checkbox"> 了解一下市场需求，构思一个RPA隐患会造成极大破坏的场景，提出解决方案</li><li><input disabled="" type="checkbox"> 查阅一些公司的技术思路，了解一下他们在安全这块的研究点及解决方案，目前我总结的有几点：<ol><li>如何最大化的职责分配保障业务安全并最小的避免对业务流程的干扰</li><li>如何有效的进行身份认证和凭证的发放与验证</li><li>是否可以通过数据加密有效保证安全，还待考虑！</li><li>日志监控这块研究一下，思路是构建一个日志记录追踪，类似微服务中的日志记录</li></ol></li></ul>]]></content>
    
    
    <summary type="html">每周安排</summary>
    
    
    
    <category term="weekly report" scheme="https://merlynr.github.io/categories/weekly-report/"/>
    
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="report" scheme="https://merlynr.github.io/tags/report/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="weekly" scheme="https://merlynr.github.io/tags/weekly/"/>
    
    <category term="RPA" scheme="https://merlynr.github.io/tags/RPA/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>RPA</title>
    <link href="https://merlynr.github.io/2021/03/28/what%E2%80%98s%20the%20mean%20of%20RPA/"/>
    <id>https://merlynr.github.io/2021/03/28/what%E2%80%98s%20the%20mean%20of%20RPA/</id>
    <published>2021-03-27T16:00:00.000Z</published>
    <updated>2021-05-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RPA"><a href="#RPA" class="headerlink" title="RPA"></a>RPA</h2><h3 id="进化历史"><a href="#进化历史" class="headerlink" title="进化历史"></a>进化历史</h3><ol><li>上个世纪二十年代 亨利·福特，改革了工业生产方式，开启了工业时代，提出了对于处理重复工作的需求</li><li>1990-2000，计算机被广泛使用，用于处理办公，提出批处理脚本和触发器</li><li>2000-2015，VBA宏编程（EXCEL宏）和BPA</li><li>2015-2018，RPA模型创建成功，并投入使用</li><li>2019~，RPA+AI，即RPA4.0被推出，被大企业认可</li></ol><p>1.2. 反应了为了解决重复工作，提出了批处理事务<br>脚本自动化：在RPA技术出现之前，脚本自动化是企业自动化可选的比较靠谱自动化落地技术。用于解决最基础的几步任务自动化，技术的缺点是没有容错、任务管理、弱鸡的基于GUI的能力。商业上的优势是，几乎可以免费使用。<br>3. VBA编程语言的创建是为了解决办公中常遇到的重复性问题【简单化】、BPA（业务流程自动化）通过深度关注业务流程，集成所有相关应用程序来实现功能，业务的实现与程序耦合太重【复杂化】</p><p>目前给出三个区别：<br><strong>集成</strong>：BPA相较于RPA对于一个业务流程提出了更加全面、更加精确的解决方法，但是BPA是一种侵入性很强的整合形式。它用自己的软件对现有的系统进行大修，并实现自己的系统。RPA不会破坏现有的业务流程。【存在优缺点】<br><strong>工作流</strong>：RPA机器人访问桌面现有的用户界面并执行人工任务，但是目前大多数机器人无法进行决策。BPA中使用的工作流程更加复杂，使用单一的处理模型来创建集成多种系统的工作流程。这些系统彼此交换和提取信息，以实现任务自动化，这需要API和数据库访问。这需要对编码和开发的大量IT支持。【应用场景的不同，无优缺点之分】<br><strong>定价</strong>：BPA定价取决于公司的规模。还有其涉及到的业务的规模。UiPath(RPA龙头企业)更加使用RPA类型来定价。【站在技术方面，RPA更加灵活，也更加适用】<br>4. 通过集成现有的业务不紧破坏了已有业务，同时过度的耦合、高昂的成本和无法普遍推广，这些条件都指定了传统化业务自动化流程只能为大公司所用。<br>这个时候屏幕抓取技术的诞生就突破了传统BPA的过度耦合的问题，它不需要过度依赖以前的业务来获取和处理数据，同时自动化与管理工具（管理系统的版本，安装，卸载等）使得RPA更易于推广，最后一个就是AI的加入，它是解放人类双手的核心，它可以根据人类先前的判断来执行任务。<br>5. RPA4.0的提出 我们不仅要看到AI为RPA提供的红利，同时也要看到RPA技术对于AI技术发展的重要意义，RPA为AI技术的发展提供了手和脚，RPA作为AI技术与现实生活的连接器，扩大了AI技术的使用范围</p><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p>RPA的核心是通过自动化、智能化技术来“代替人”进行重复性、低价性、无需人工决策等固定性流程化操作，从而有效的提高工作效率，减少错误。</p><p>The main difference between software<br>robots and applications is the identity access<br>management (IAM) domain —  RPA instances<br>behave like an individual user. </p><h3 id="RPA进化四个阶段"><a href="#RPA进化四个阶段" class="headerlink" title="RPA进化四个阶段"></a>RPA进化四个阶段</h3><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021413/1618314304547.png" alt="四个阶段"></p><p>1：辅助性RPA（Assisted RPA）<br>　　在RPA 1.0阶段，作为“虚拟助手”出现的RPA，几乎涵盖了机器人自动化的主要功能，以及现有桌面自动化软件的全部操作。部署在员工PC机上，以提高工作效率。缺点则是难以实现端到端的自动化，成规模地应用还很难。<br>　　2：非辅助性RPA（Unassisted RPA）<br>　　在RPA 2.0阶段，被称为“虚拟劳动力”的RPA，主要目标即实现端到端的自动化，以及虚拟员工分级。主要部署在VMS虚拟机上，能够编排工作内容，集中化管理机器人、分析机器人的表现等。缺点则是对于RPA软件机器人的工作仍然需要人工的控制和管理。<br>　　3：自主性RPA（Autonomous RPA）<br>　　在RPA 3.0阶段，其主要目标是实现端到端的自动化和成规模多功能虚拟劳动力。通常部署在云服务器和SaaS上，特点是实现自动分级、动态负载平衡、情景感知、高级分析和工作流。缺点则是处理非结构化数据仍较为困难。<br>　　4：认知性RPA（Cognitive RPA）<br>　　RPA 4.0将是未来RPA发展的方向。开始运用人工智能、机器学习以及自然语言处理等技术，以实现非结构化数据的处理、预测规范分析、自动任务接受处理等功能。<br>　　目前，尽管大多数RPA软件产品，都还集中在2.0 - 3.0之间，但其发展已相当成熟，产品化程度亦是很高。一些行业巨头已经开始向RPA 4.0发起了探索。</p><h3 id="播放几个视频"><a href="#播放几个视频" class="headerlink" title="播放几个视频"></a>播放几个视频</h3><h3 id="扩展理解"><a href="#扩展理解" class="headerlink" title="扩展理解"></a>扩展理解</h3><p>轻量级IT，任何电子设备都可以被操控，<br>智能客服、智能家居，以及很多重复性较高、朝左流程固定的办公工作都可以被替代</p><h2 id="国内外现状"><a href="#国内外现状" class="headerlink" title="国内外现状"></a>国内外现状</h2><p>就国内外发展现状进行对比，全球五强RPA占有47%的市场，中国国产RPA目前智能更多被使用在能源、医疗、政务等一些领域。</p><h3 id="国内外"><a href="#国内外" class="headerlink" title="国内外"></a>国内外</h3><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021412/1618235359990.png" alt="国内外RPA"></p><p>国内主要厂商：来也科技、达观数据、云扩科技、艺赛旗、阿里云等<br>国外及世界领先的厂商：UiPath(免费社区版)、Blue Prism、Automation Anywhere</p><p>虽然国际RPA依旧扮演领导者和行业的规则的制定者，但是在各种新技术与RPA融合进程中，以及在生态建设成为RPA厂商主要竞争力的主流打法上，国产RPA并没有落后。甚至在一些方面，已经超越某些国外厂商。</p><p>可以通过近几年的融资金额和市场估值可以看出国产RPA也在蓬勃发展。</p><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021413/1618313802380.png" alt="2020年融资"></p><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021413/1618314424625.png" alt="近五年的投资事件"></p><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p><a href="https://zhuanlan.zhihu.com/p/275757075">https://zhuanlan.zhihu.com/p/275757075</a></p><h3 id="UiPath"><a href="#UiPath" class="headerlink" title="UiPath"></a>UiPath</h3><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021413/1618316991750.png" alt="UiPath服务器平台三层逻辑"></p><p>1）表示层<br>数据REST API端点<br>通知API<br>Web应用程序<br>2）Web服务层xiac<br>业务逻辑实现（下层为单个任务节点的实现提供服务，上层是bot根据任务队列，任务组成等多因素来控制任务执行）<br>3）持久层<br>弹性搜索<br>SQL服务器</p><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021413/1618317691754.png" alt="设计框架"></p><ol><li>开发人员在UiPath Studio中构建流程</li><li>使用Development Orchestrator和Quality Assurance Qrcheestrator对其进行测试；完成后，他们将工作流（未打包）签入uiatph中主UiProcess Library文件夹（在VCS上）</li><li>将工作流封装，并保存到QA，为本机专有使用</li><li>如果在测试期间发现任何问题，则重复上述步骤。</li><li>一旦所有的QA测试都通过了，包就被复制到生产环境（P包）</li><li>生产过程正在进行，由生产机器人运行</li></ol><ul><li><p>UiPath由studio（开发工具），Orchestrator（自动化云平台和监控平台），robot（运行已开发的机器人服务）组成</p></li><li><p>Robot分为Front Office Robot和Back Office Robot.缩写分别为FOR和BOR。 FOR需要手工启动。</p></li><li><p>BOR需要配合Orchestrator启动。</p></li><li><p>现在又分别叫Attended和Unattended：</p></li><li><p>Attended要有人照看，不能在电脑锁屏的状态下运行自动工作流</p></li><li><p>Unattended不用人工照看，可以在电脑锁屏的状态下运行自动工作流，由Orchestrator远程执行</p></li></ul><blockquote><p>Invokes Repository 调用（调用存储库）==公用部分，被多方调用 #00BCD4==<br>Reusable Code Library 可重用代码库</p></blockquote><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021413/1618320047098.png" alt="新版设计框架"></p><ul><li>提供免费社区版</li><li>产品线丰富，拓展了AI、process mining方面的能力</li><li>它提供了多种托管选项，例如云环境，虚拟机和终端服务</li><li>它支持各种Web和桌面应用程序</li><li>它支持自动登录功能来运行机器人</li><li>它包括可与 .Net，Java，Flash，PDF，Legacy，SAP配合使用的抓取解决方案，且准确性最高</li></ul><h3 id="阿里云RPA"><a href="#阿里云RPA" class="headerlink" title="阿里云RPA"></a>阿里云RPA</h3><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021413/1618321774264.png" alt="流程编辑器"></p><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021413/1618323038585.png" alt="整体结构"></p><p>阿里云RPA4.0采用主流C/S架构模式，前端客户端采用.net平台，基于Windows系统具有自主研发的SDK及各项功能，后端服务端采用Linux（CentOS）操作系统，提供各类后台服务和组件。</p><ul><li>对接阿里达摩院，NLP、OCR等人工智能能力深度整合，让机器人更智能</li><li>拥有丰富的SDK自动化模块，支持自定义SDK库</li><li>阿里云统一售后支持体系</li></ul><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021413/1618323129695.png" alt="场景"></p><h3 id="实在智能-章鱼数字员工"><a href="#实在智能-章鱼数字员工" class="headerlink" title="实在智能-章鱼数字员工"></a>实在智能-章鱼数字员工</h3><p>解决问题：<br>    - 用户可以根据自身需求指定AI套件<br>    - 通用AI能力精度不足</p><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021415/1618463061303.png" alt="AaaS架构"></p><ol><li>RPA与算法平台进行无缝衔接</li></ol><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021415/1618463296265.png" alt="与算法平台衔接"></p><p>【视频–实在智能】</p><ol start="2"><li>集群以及AI定制</li></ol><blockquote><p>不同的系统对于计算能力，内容，硬盘以及网络的要求是不同的，可以根据系统不同分集群部署，不如算法运行在GPU上，而小型数据中台选择数据库服务器集群等；同时用户可以根据自身要求，选择算法和算法服务集群。</p></blockquote><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021415/1618463370738.png" alt="根据用户需求定制"></p><ol start="3"><li>算法开发训练</li></ol><blockquote><p>集成传统BPA的优势，为当前业务提供更加精确的算法</p></blockquote><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021415/1618463186299.png" alt="算法开发训练"></p><p><strong>产品优势：</strong></p><blockquote><p>北斗****<br>1.传统的无锚点拾取，只能在简单场景<br>2.当页面中出现相同元素时通过附近元素进行判断并标识,选择不当容易导致流程失败<br>3.完全无感知的自动锚点选择，通过step-of-out图神经网络技术学习页面上的拓扑关系</p></blockquote><blockquote><p>神盾<br>通过监控流程，如果发生异常，则通过北斗自动修复元素来修正自动流程</p></blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzI2NjE2NjQ0Ng==&mid=2247484934&idx=1&sn=d7d105996c81ac9af8a5567a6db799aa&chksm=ea930fc7dde486d137d60d0a013db9d2f7390c0b3876da95a47ef8b0f17857fbab6fa40bd17b&scene=21#wechat_redirect">开源框架</a></p><blockquote><p>魔镜</p></blockquote><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021415/1618464900207.png" alt="自动化开发"></p><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021415/1618464926504.png" alt="魔镜"></p><p>  目前各大公司对于RPA的使用多处于RPA2.0-RPA3.0之间，即需要RPA开发者介于，而魔镜这种通过视频与日志结合的开发模式将很大程度降低客户使用成本。</p><h3 id="框架总结"><a href="#框架总结" class="headerlink" title="框架总结"></a>框架总结</h3><p>RPA解决方案是依托于各类先进信息技术手段的虚拟劳动力，根据预先设定的程序操作指令对任务进行自动化处理，实现业务流程由机器人自动化处理。</p><p><strong>RPA能做的</strong></p><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021413/1618320374905.png" alt="可以满足我们的"></p><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021413/1618323364197.png" alt="新的行业标准"></p><ol><li>作为辅助甚至代替传统职工的工作软件，它需要员工的权限，但是却又脱离了系统的安全保障，这就造成了安全危机。<br>任子旭的对于网络安全和内部合规的提议：<br>对网络安全和内控合规的要求和约束时，主要是两个思路：<strong>遵从和自证清白</strong>。</li></ol><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021413/1618320690337.png" alt="保障安全"></p><ol start="2"><li>作为一个辅助软件，本身高效性的前提是与相对应的工作量对照的，这就需要在配置时根据公司业务量来取舍，防止资源被浪费</li><li>虚拟化和环境一致性。整个项目的交付过程中，并没有那么简单。我们要考虑空间环境、系统环境、程序适用、版本兼容等多个因素。</li></ol><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021413/1618320927712.png" alt="部署中的注意点"></p><h2 id="研究内容"><a href="#研究内容" class="headerlink" title="研究内容"></a>研究内容</h2><p>RPA到底可以发展到什么程度？</p><h3 id="可研究点"><a href="#可研究点" class="headerlink" title="可研究点"></a>可研究点</h3><h4 id="RPA-网络安全风险"><a href="#RPA-网络安全风险" class="headerlink" title="RPA 网络安全风险"></a>RPA 网络安全风险</h4><ol><li>滥用特权访问</li></ol><ul><li>攻击者可能能够危及机器人使用的管理员帐户。攻击者可以使用管理员帐户获得对敏感数据的访问权限</li><li>在离职之前，前员工可以编程机器人删除重要数据并中断业务流程</li></ul><ol start="2"><li>披露敏感数据</li></ol><ul><li>机器人开发人员可能会错误地编写BOT，以将高机密数据（例如信用卡信息）上传到公众通过Web访问的数据库。</li><li>机器人开发人员可以使用他或她的账户窃取业务其他服务信息</li></ul><ol start="3"><li>安全漏洞</li></ol><ul><li>虚拟机环境中可能存在安全漏洞，这是机器人运行的环境。</li><li>机器人开发人员编程机器人发送/接收敏感数据而不加密。此数据很脆弱，可以由攻击者利用</li></ul><ol start="4"><li>拒绝服务</li></ol><ul><li>一些不良的编程实践可以使机器人消耗所有虚拟机系统资源并导致虚拟机变得无响应，因此无法执行任何工作</li><li>虚拟机可能受到计划受到计划升级或网络维护的影响，可能导致中断损失。</li></ul><p><strong>应对策略</strong></p><ol><li>先进的职责分工，这就限制RPA用户只能执行分配给分配的任务，并且它们没有提升访问权限。同时也要限制代码开发人员与使用者的行为。</li></ol><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021414/1618390329616.png" alt="主要RPA角色"></p><ol start="2"><li>数字身份认证和凭证的发放与验证，大部分黑客攻击都是在凭据被损害后发起的。为了避免这种情况，就需要设置机器人为最小的特权角色，那么机器人只能执行它的设计，并且其用户角色不能用于执行其他功能</li><li>数据加密，保证数据在传输过程前被加密，以及作业完成后删除。</li><li>监视日志并在内部控件损坏时执行审计，机器人活动可用于监测异常行为并进行审计，以防问题存在问题。</li><li>在发布生产代码之前，需要先扫描代码的漏洞，可以通过一些工具实现，Dynamic Application Security Testing (DAST) 【动态应用安全测试】and Fortify. </li></ol><h4 id="业务流程转型，RPA部署的效率、评估和解决方案"><a href="#业务流程转型，RPA部署的效率、评估和解决方案" class="headerlink" title="业务流程转型，RPA部署的效率、评估和解决方案"></a>业务流程转型，RPA部署的效率、评估和解决方案</h4><h4 id="对于其他功能的聚合，如应用控制，OCR-桌面自动化，中央管理等"><a href="#对于其他功能的聚合，如应用控制，OCR-桌面自动化，中央管理等" class="headerlink" title="对于其他功能的聚合，如应用控制，OCR,桌面自动化，中央管理等"></a>对于其他功能的聚合，如应用控制，OCR,桌面自动化，中央管理等</h4><h4 id="分区平台的共享服务必然会被需求较小的公司需求"><a href="#分区平台的共享服务必然会被需求较小的公司需求" class="headerlink" title="分区平台的共享服务必然会被需求较小的公司需求"></a>分区平台的共享服务必然会被需求较小的公司需求</h4><h4 id="跨平台的应用操作能力"><a href="#跨平台的应用操作能力" class="headerlink" title="跨平台的应用操作能力"></a>跨平台的应用操作能力</h4><h4 id="容器化"><a href="#容器化" class="headerlink" title="容器化"></a>容器化</h4><h4 id="RPA开发运维"><a href="#RPA开发运维" class="headerlink" title="RPA开发运维"></a>RPA开发运维</h4><p>从软件供应商转变为服务供应商<br>在共享服务中，自动化会变得极其慢，集群</p><h3 id="后期安排"><a href="#后期安排" class="headerlink" title="后期安排"></a>后期安排</h3><p>UiPath、tensorFlow</p>]]></content>
    
    
    <summary type="html">学习汇总</summary>
    
    
    
    <category term="RPA" scheme="https://merlynr.github.io/categories/RPA/"/>
    
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="RPA" scheme="https://merlynr.github.io/tags/RPA/"/>
    
  </entry>
  
  <entry>
    <title>2021-03-26【周总结】</title>
    <link href="https://merlynr.github.io/2021/03/24/2021-03-24%E3%80%90Week%E3%80%91/"/>
    <id>https://merlynr.github.io/2021/03/24/2021-03-24%E3%80%90Week%E3%80%91/</id>
    <published>2021-03-23T16:00:00.000Z</published>
    <updated>2021-05-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本周安排"><a href="#本周安排" class="headerlink" title="本周安排"></a>本周安排</h2><ul><li><input disabled="" type="checkbox"> MIT6.004课程完成</li><li><input checked="" disabled="" type="checkbox"> 学位英语</li><li><input disabled="" type="checkbox"> 继续查询项目依赖bug</li><li><input checked="" disabled="" type="checkbox"> 查询论文，并阅读总结两篇</li><li><input checked="" disabled="" type="checkbox"> openRPA实例实现</li></ul><h2 id="完成情况"><a href="#完成情况" class="headerlink" title="完成情况"></a>完成情况</h2><blockquote><p>主要精力放在学位英语上了，后期学习了部分MIT6003的课程，以及最后研究了openRPA的使用</p></blockquote><p><strong>论文方面</strong></p><pre><code>    与openRPA技术相关的论文还是没有查阅到，只是查阅了一些综述以及国内外对于RPA预测的推文，现在归纳了三个可研究点：</code></pre><ol><li>RPA机器人在运行时一般需要最高权限，这就可能引起黑客的攻击直接让过传统权限控制系统，通过直接攻击黑客来攻击系统</li><li>找到一个适合的场景，做RPA+AI，类似文本、语音、或者直接获取通讯记录来给RPA传输指令，这个研究点是目前比较常被提到的RPA4.0</li><li>RPA缺乏对于未知问题的解决能力，这个点预计很难研究，这是一个普遍问题</li></ol><p><strong>个人课程学习</strong></p><blockquote><p>空间技术课程提到一个“社会计算”，这个是杨老师他们大实验的学长有过研究就是给我们科普了一下，不过李波老师提到了他们大实验室有个好的idea就是搭建一个实验室的微服务系统，然后把每届的研究成果数据都放上去，以方便给后几届学弟学妹使用，老师我觉得我们实验室与师兄师姐交流太少了，而且他们也很忙几乎没有空和我们交流，这个idea也可以实现在我们实验室，对于学生提供了一个很好的学习见解。</p></blockquote><p><strong>公司方面</strong></p><blockquote><p>每周没有任务跟进，后期会对公司依赖bug进行查询补充</p></blockquote><h2 id="下周安排"><a href="#下周安排" class="headerlink" title="下周安排"></a>下周安排</h2><ul><li><input disabled="" type="checkbox"> 根据已经发现的RPA研究点中的第一个小点进行查阅论文并总结</li><li><input disabled="" type="checkbox"> 今天对openRPA进行了初步阅读，发现openRPA是C#的项目，本身没有学习过，会花两到三天进行学习C#语言，然后阅读源码</li><li><input disabled="" type="checkbox"> 继续学习MIT6003课程</li><li><input disabled="" type="checkbox"> 补充公司项目依赖部分bug</li><li><input disabled="" type="checkbox"> 每天尽量听会英语课程</li></ul>]]></content>
    
    
    <summary type="html">每周学习总结</summary>
    
    
    
    <category term="weekly report" scheme="https://merlynr.github.io/categories/weekly-report/"/>
    
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="report" scheme="https://merlynr.github.io/tags/report/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="weekly" scheme="https://merlynr.github.io/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>2021-3-19【周总结】</title>
    <link href="https://merlynr.github.io/2021/03/19/2021-3-19%E3%80%90%E5%91%A8%E6%80%BB%E7%BB%93%E3%80%91/"/>
    <id>https://merlynr.github.io/2021/03/19/2021-3-19%E3%80%90%E5%91%A8%E6%80%BB%E7%BB%93%E3%80%91/</id>
    <published>2021-03-18T16:00:00.000Z</published>
    <updated>2021-05-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本周安排"><a href="#本周安排" class="headerlink" title="本周安排"></a>本周安排</h2><ul><li><input checked="" disabled="" type="checkbox"> 熟悉OpenRPA框架</li><li><input checked="" disabled="" type="checkbox"> 通过代码实操学习对数据库的操作</li><li><input checked="" disabled="" type="checkbox"> 阅读相关论文–流程机器人+AI</li><li><input checked="" disabled="" type="checkbox"> 做网络安全课程PPT</li><li><input checked="" disabled="" type="checkbox"> 英语学习</li><li><input disabled="" type="checkbox"> 对比五个框架，并总结</li></ul><h2 id="后加入的任务"><a href="#后加入的任务" class="headerlink" title="后加入的任务"></a>后加入的任务</h2><ol><li>帮助公司接口优化整理项目依赖资料</li><li>完成部分公司项目依赖版本与最新版之间错误的总结</li></ol><h2 id="完成情况"><a href="#完成情况" class="headerlink" title="完成情况"></a>完成情况</h2><blockquote><p>本周主要主要精力集中于论文、学习实操了一些mabtis代码后面有花费了不到两天整合公司项目依赖相关材料,五个框架没有整理太多。</p></blockquote><p><strong>论文方面：</strong></p><pre><code>观看了为了“提出轻量级IT程序与自动化流程集成的规范化”的论文和The Forrester Wave™2018年发表的RPA总结汇报。</code></pre><p>1、第一篇中详细阐明RPA中的轻量IT的使用场景，规则以及与传统系统的区别，更加容易明白轻量IT在自动化流程中的作用，加深了对于RPA的理解—–只要有载体可以实现所有人的行为【可能一开始从五个框架入手，被局限于自动化测试了】<br>2、第二篇从报告中了解较为认可的15个成熟的框架，以及这个报告详细阐述了RPA评定的规则</p><p><strong>个人课程学习</strong></p><ul><li>加深了在小论文方面的学习</li><li>对于小论文的发表有了基本的概念，现在加强论文方面阅读，寻找该方向研究点</li></ul><p> <strong>公司方面</strong></p><ul><li>主要参与负责总结公司项目依赖版本以及总结公司当前版本的无法修补的bug情况。前期基本完成，后期由于工作量比较大，完成了部分，我问了实验室其它人，他们说好像优化完成了，涛总也没问过我了，后期的bug调研就没有跟进了</li></ul><h2 id="下周安排"><a href="#下周安排" class="headerlink" title="下周安排"></a>下周安排</h2><ol><li>先将2018的年度关于RPA总结报告看完，理解RPA的评定规范</li><li>详细阅读OpenRPA源码，总结优缺点</li><li>查询与RPA相关的AI算法，扩展学习</li><li>将英语学习提上日常，每天背后单词，练下口语</li><li>不能放下代码能力，依旧进行少量代码实操</li></ol>]]></content>
    
    
    <summary type="html">每周学习总结</summary>
    
    
    
    <category term="weekly report" scheme="https://merlynr.github.io/categories/weekly-report/"/>
    
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="report" scheme="https://merlynr.github.io/tags/report/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="weekly" scheme="https://merlynr.github.io/tags/weekly/"/>
    
    <category term="plan" scheme="https://merlynr.github.io/tags/plan/"/>
    
  </entry>
  
  <entry>
    <title>五个RPA框架通读</title>
    <link href="https://merlynr.github.io/2021/02/22/%E4%BA%94%E4%B8%AARPA%E6%A1%86%E6%9E%B6%E9%80%9A%E8%AF%BB/"/>
    <id>https://merlynr.github.io/2021/02/22/%E4%BA%94%E4%B8%AARPA%E6%A1%86%E6%9E%B6%E9%80%9A%E8%AF%BB/</id>
    <published>2021-02-21T16:00:00.000Z</published>
    <updated>2021-05-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Robot-Framework"><a href="#Robot-Framework" class="headerlink" title="Robot Framework"></a>Robot Framework</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li>接受测试驱动开发（ATDD），行为驱动开发（BDD）和机器人流程自动化（RPA）</li><li><a href="https://robotframework.org/#examples">社区</a></li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><blockquote><p>Robot Framework的环境搭建</p></blockquote><ol><li>安装wxpython需要安装wheel，不然无法打包安装======</li><li>需要安装与chrome版本匹配的driver到目录中</li></ol><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><ol><li>通过代码来进行生产</li></ol><ul><li>项目组成</li></ul><p><img src="https://gitee.com/merlynr/img-store/raw/master/202136/1615015210514.png" alt="项目组成"></p><blockquote><p>项目见压缩文件—项目一，下面是robot的代码结构组成</p></blockquote><p><a href="https://github.com/robotframework/QuickStartGuide/blob/master/QuickStart.rst#executing-this-guide">参考文档</a></p><p>robot核心结构是由三部分组成的，一个是keywords的依赖，第二个是关键字，最后则是执行动作</p><p><img src="https://gitee.com/merlynr/img-store/raw/master/202136/1615015362634.png" alt="robot结构"></p><p><img src="https://gitee.com/merlynr/img-store/raw/master/202136/1615015469911.png" alt="关键字组成"></p><p><img src="https://gitee.com/merlynr/img-store/raw/master/202136/1615015588995.png" alt="动作"></p><p>运行效果，打包视频-robot1【视频总一个robot执行了两动作，所以结果都是两个】</p><p><img src="./videos/robot1.mkv" alt="robot1"></p><ol start="2"><li>通过较为成熟的工具–robocorp Lab</li></ol><p>==此工具可以实现的，robot framework都可以实验 #009688==</p><ul><li>结构组成</li></ul><p><img src="https://gitee.com/merlynr/img-store/raw/master/202136/1615016378239.png" alt="项目结构"></p><p><img src="https://gitee.com/merlynr/img-store/raw/master/202136/1615016399861.png" alt="robot结构"></p><ul><li>较为简单的栗子，自动打开浏览器然后访问url</li></ul><p><img src="./videos/robocorp1.mkv" alt="robocorp1"></p><ul><li>另一个栗子，登录功能的测试</li></ul><p><img src="./videos/robocorp2.mkv" alt="robocorp2"></p><blockquote><p>总结：和邹瑞进行过交流确实这个框架确实可以提升测试效率，由于执行动作可以通过传参来改变动作执行对象，所以可重复度明显提升，目前没有感觉到人工智能的应用点，下步继续了解。</p></blockquote><h2 id="TagUI"><a href="#TagUI" class="headerlink" title="TagUI"></a>TagUI</h2><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><pre><code>    就是传统的，较为灵活但是复用性低；这个框架可以控制鼠标模拟动作    </code></pre><p><img src="https://gitee.com/merlynr/img-store/raw/master/202136/1615018851173.png" alt="代码结构"></p><h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><ol><li><p>访问网站并截图</p><p> <img src="https://gitee.com/merlynr/img-store/raw/master/202136/1615019129522.png" alt="源码"></p></li></ol><p><img src="./videos/tagui_1.mkv" alt="tagui_1"></p><p>==tagui在模拟人的行为上确实比robot framework #00BCD4==</p><ol start="2"><li>访问github上项目并下载等待完成</li></ol><p><img src="./videos/tagui_2.mkv" alt="tagui_2"></p><ol start="3"><li>可以通过表格来设置参数，高重复性</li></ol><p>  <img src="./videos/tagui_3.mkv" alt="tagui_3"></p><pre><code>      还有一些官方也提到可以获取数控中数据来进行测试，也可以通过中文命令来测试等</code></pre><h2 id="UI-Vision"><a href="#UI-Vision" class="headerlink" title="UI.Vision"></a>UI.Vision</h2><blockquote><p>有两个，一个是浏览器插件，另一个是桌面版。桌面版适用于手机上app的测试【没有进行实验】</p></blockquote><p><img src="./videos/2021-03-06_17-29-08.mkv" alt="2021-03-06 17-29-08"></p><p>总结：很傻瓜式，所有动作需要一模一样，否则无法找到指定的属性来换参，前面有一点不一样，后面将可能无法执行。</p><h2 id="open-RPA"><a href="#open-RPA" class="headerlink" title="open RPA"></a>open RPA</h2><p><a href="https://open-rpa.readthedocs.io/en/latest/">https://open-rpa.readthedocs.io/en/latest/</a></p><p><a href="https://docs.openiap.io/">https://docs.openiap.io/</a></p>]]></content>
    
    
    <summary type="html">打牢基础</summary>
    
    
    
    <category term="RPA" scheme="https://merlynr.github.io/categories/RPA/"/>
    
    
    <category term="graduate student" scheme="https://merlynr.github.io/tags/graduate-student/"/>
    
    <category term="study" scheme="https://merlynr.github.io/tags/study/"/>
    
    <category term="RPA" scheme="https://merlynr.github.io/tags/RPA/"/>
    
  </entry>
  
</feed>

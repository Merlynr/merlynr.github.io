<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>挖掘业务流程，结合机器学习进行业务预测分析</title>
      <link href="2021/05/25/%E6%8C%96%E6%8E%98%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%EF%BC%8C%E7%BB%93%E5%90%88%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%BF%9B%E8%A1%8C%E4%B8%9A%E5%8A%A1%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90/"/>
      <url>2021/05/25/%E6%8C%96%E6%8E%98%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%EF%BC%8C%E7%BB%93%E5%90%88%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%BF%9B%E8%A1%8C%E4%B8%9A%E5%8A%A1%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="基于机器学习的流程异常预测行为"><a href="#基于机器学习的流程异常预测行为" class="headerlink" title="基于机器学习的流程异常预测行为"></a>基于机器学习的流程异常预测行为</h2><p><img src="./attachments/基于机器学习的流程异常预测方法_魏懿.pdf" alt="基于机器学习的流程异常预测方法_魏懿"></p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><blockquote><p>通过挖掘流程执行的==日志记录 #F44336==和活动执行==时间信息 #F44336==，基于机器学习方法的异常检测方法，实现实时预测业务流程中的超 期 异 常 和 流 程 行 为 异 常。</p></blockquote><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><blockquote><p>异常(预期的，完全意外的)</p></blockquote><ol><li>流程超期、资源不可用、活动执行失败等和完全意外的异常</li></ol><blockquote><p>现有的流程异常检测方法</p></blockquote><ol><li>主动 的 设 置 时 间 检 查点、动态检查，或 被动地基于异常发生后捕捉异常、处理异常的机制</li><li>主动设置时间检查点的方法有两个弊端，第一个设置点的位置无法精确判断，第二个是系统状态是动态的，受生产环境等诸多条件影响，所以主动i设置会造成很多新的问题</li><li>被动处理超期异常的方法，失去了对业务流程管理的主动性，从而将导致工作流期望的目标延迟或付出更大的开销。【即失去对于流程预测的主动性】</li></ol><h3 id="目前国内外研究动态"><a href="#目前国内外研究动态" class="headerlink" title="目前国内外研究动态"></a>目前国内外研究动态</h3><ol><li>几个小的分页的处理</li><li>百度，谷歌可搜索</li></ol><h3 id="本文方法"><a href="#本文方法" class="headerlink" title="本文方法"></a>本文方法</h3><blockquote><p>提出一种基于活动执行时间和比例关系的方法，通过学习历史流程执行日志中活动时间信息，根据正在执行的待预测流程的日志及状态，预测其是否为异常流程以及异常的类型。并且，本文提出通过计算活动执行时间之间的比例关系作为流程特征加入机器学习算法，运用机器学习中监督学习的分类器以预测流程是否会发生超期异常（流程执行总时间超过预设最终期限），同时使用非监督学习的离群点检测算法根据历史数据中活动执行时间比例关系判定流程行为异常。结合两种算法的结果对流程异常预测做出进一步的分类和分析。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> paper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> RPA </tag>
            
            <tag> paper </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-05-24【Week】</title>
      <link href="2021/05/24/2021-05-24%E3%80%90Week%E3%80%91/"/>
      <url>2021/05/24/2021-05-24%E3%80%90Week%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h2 id="本周安排"><a href="#本周安排" class="headerlink" title="本周安排"></a>本周安排</h2><ul><li>[ ] 重新梳理研究方向</li><li>[ ] 寻找并阅读相关文章两篇</li><li>[ ] 坚持英语学习20mis/everyday</li><li>[ ] 沙盒搭建</li></ul><h2 id="完成情况"><a href="#完成情况" class="headerlink" title="完成情况"></a>完成情况</h2><ol><li>将docker有关的操作过了一遍</li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> weekly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-05-15【Week】</title>
      <link href="2021/05/19/2021-05-15%E3%80%90Week%E3%80%91/"/>
      <url>2021/05/19/2021-05-15%E3%80%90Week%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h3 id="本周安排"><a href="#本周安排" class="headerlink" title="本周安排"></a>本周安排</h3><ul><li>[ ] 源码分析</li><li>[ ] 预开题准备</li><li>[ ] 重新整理并寻找合适的研究点</li></ul><h3 id="任务完成情况"><a href="#任务完成情况" class="headerlink" title="任务完成情况"></a>任务完成情况</h3><ol><li>源码分析已经完成，tagui的源码的难点主要是语言多，但是其中逻辑不是很难</li><li>这次预开题，我是比较认真准备的，当时讲的时候人比较多，可能比较着急哇，我主要为了解决RPA中可并发执行任务的功能，这块的难点就是资源分配的问题，所以涉及了大量资源分配的研究，目前国内外RPA这方面都比较淡化，没有很好的解决方式，所以我感觉还是可以的：）</li><li>现在在看老师给发的文档，大部分我也看过了，里面的点太笼统，面太大，当时和老师交流后，重新理解了一下，是研究机器学习在业务流程中处理文档，表格，但是目前就RPA里面来说，自动获取文件中信息处理的比较好，各个公司都没有在这块上投入更多资源</li></ol><h3 id="汇总文件补充"><a href="#汇总文件补充" class="headerlink" title="汇总文件补充"></a>汇总文件补充</h3><blockquote><p>平时学习时，总结都是单独的，所以这块就引用上周写的汇总了</p></blockquote><ol><li>tagui源码分析</li></ol><p><img src="./attachments/TagUI源码阅读及分析.pdf" alt="TagUI源码阅读及分析"></p><ol><li>预开题PPT</li></ol><p><img src="./attachments/RPA动态感知分配业务资源的研究与应用.pptx" alt="RPA动态感知分配业务资源的研究与应用"></p><ol><li>重新整理—-未完成</li></ol><p><img src="./attachments/RPA+AI.pdf" alt="RPA+AI"></p>]]></content>
      
      
      <categories>
          
          <category> weekly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> weekly </tag>
            
            <tag> plane </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPA+AI</title>
      <link href="2021/05/17/RPA+AI/"/>
      <url>2021/05/17/RPA+AI/</url>
      
        <content type="html"><![CDATA[<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="https://developer.aliyun.com/group/rpa?spm=a2c6h.12873639.0.0.65b05d65mS6OlC#/?_k=agnoe0">阿里云RPA社区</a></p><p><a href="https://zhuanlan.zhihu.com/p/59034887?utm_oi=786717341600858112">阿里云RPA（机器人流程自动化）系列</a></p><p><a href="https://www.yuque.com/aliyun_rpa">阿里云RPA文档</a></p><p><a href="https://github.com/rpabotsworld/awesome-rpa">资源</a></p><h2 id="阅读记录"><a href="#阅读记录" class="headerlink" title="阅读记录"></a>阅读记录</h2><h3 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h3><h4 id="阿里云RPA系列"><a href="#阿里云RPA系列" class="headerlink" title="阿里云RPA系列"></a>阿里云RPA系列</h4><ol><li>文件信息的处理—提取和处理结构和半结构化数据</li><li>异常处理—宕机、流程回滚、中断后的流程接续等问题</li><li>业务流程从明确化变为高适配的—-智能处理【制定与运行过程中】</li><li>各类场景—大量重复【基本配置通用性高】、可贴合各类场景【规则灵活，外附组件可灵活配置】</li></ol><h4 id="S公司智能财务机器人共享中心建设与实践"><a href="#S公司智能财务机器人共享中心建设与实践" class="headerlink" title="S公司智能财务机器人共享中心建设与实践"></a>S公司智能财务机器人共享中心建设与实践</h4><p><a href="https://m.hanspub.org/journal/paper/34237">URL</a></p><ol><li>分布式部署时，对于资源无法实时有效判断其是否有效可用</li><li>将robot集中到资源池中，供全公司使用，打破单元机器人的壁垒—-无法有效的共享数据，但是安全受到了极大威胁</li></ol><h4 id="一种基于RPA机器人共享中心的自动审批的方法【专利】"><a href="#一种基于RPA机器人共享中心的自动审批的方法【专利】" class="headerlink" title="一种基于RPA机器人共享中心的自动审批的方法【专利】"></a>一种基于RPA机器人共享中心的自动审批的方法【专利】</h4><p><a href="http://www10.drugfuture.com/pdfview/generic/web/viewer.html?file=/cnpat/package/%E5%8F%91%E6%98%8E%E4%B8%93%E5%88%A9%E7%94%B3%E8%AF%B7%E8%AF%B4%E6%98%8E%E4%B9%A6CN201911335237.4.pdf">PDF</a></p><ol><li>没有实际创新点，就是为用户提供了访问权限，根据用户自己提交的内容，进行过滤分类，然后由robot进行访问对应的资源进行处理，专利只是讲了研究内容，具体算法和实践没有提到，所以它所涉及到的对机器人共享中心进行分级调度没有表现出来。</li></ol><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><blockquote><p>阿里云版本迭代</p></blockquote><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021517/1621238642819.png" alt="阿里云版本迭代方案"></p><h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><ol><li>流程处理未知问题的智能化</li><li>中间通信安全</li><li>重新定义RPA，目前RPA，只是一个外接的控制工具，而不能替代人工</li><li>==* #F44336==挖掘业务流程，结合机器学习进行业务预测</li><li></li></ol><h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><ol><li>无数据比对，无证明方式，用数据证明有效改进</li></ol><p><a href="https://wap.cnki.net/touch/web/Dissertation/Article/10013-1019047248.nh.html">https://wap.cnki.net/touch/web/Dissertation/Article/10013-1019047248.nh.html</a></p><p><a href="https://www.touqikan.com/jsjj/660421.html">https://www.touqikan.com/jsjj/660421.html</a></p>]]></content>
      
      
      <categories>
          
          <category> RPA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> RPA </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习--吴恩达</title>
      <link href="2021/05/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0--%E5%90%B4%E6%81%A9%E8%BE%BE/"/>
      <url>2021/05/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0--%E5%90%B4%E6%81%A9%E8%BE%BE/</url>
      
        <content type="html"><![CDATA[<p>监督学习—-因子和结果都给出，让机器学习判断<br>无监督学习—无规则学习 【聚类属于无监督】</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nicholas Burns</title>
      <link href="2021/05/06/Nicholas%20Burns/"/>
      <url>2021/05/06/Nicholas%20Burns/</url>
      
        <content type="html"><![CDATA[<p><strong>身份：</strong><br>•    罗伊和芭芭拉·古德曼（Roy and Barbara Goodman）哈佛大学肯尼迪学校外交与国际关系实践家庭教授<br>•    Belfer Center董事会成员<br>•    外交项目的未来教席<br>•    欧洲与跨大西洋关系项目教席<br>•    中东倡议联盟会员<br>•    美国国务秘书项目主任</p><p><strong>个人履历见附件</strong></p><p><img src="./attachments/RNB_Bio_Full_1.pdf" alt="RNB_Bio_Full_1"></p><p><strong>联系方式：</strong></p><ul><li>twitter： @rnicholasburns</li><li>phone： 617-495-2495</li><li>邮箱：nicholas_burns@hks.harvard.edu</li></ul><p><strong>助理信息：</strong></p><ul><li>艾莉森·希格斯（Alison Hillegeist）</li><li>电邮：alison_hillegeist@hks.harvard.edu</li><li>电话：617-495-2495</li><li>Mailing Address: John F. Kennedy School of Government、79 JFK St.、Cambridge, Massachusetts</li></ul><p><strong>家庭：</strong><br>妻子伊丽莎白·贝利（Elizabeth A. Baylies）育有三个女儿：莎拉（Sarah），伊丽莎白（Elizabeth）和卡罗琳（Caroline）</p><p><a href="https://www.youtube.com/watch?v=BloYsnYLxhM&amp;t=42s">信息来源-1</a></p><ul><li>Nicholas Burns与妻子贝利在巴黎美国大学（American University of Paris）在1982年相识并相爱 </li><li>莎拉（Sarah）: 2017.05 毕业于巴黎美国大学（AUP）</li></ul><p><strong>官方个人网站：</strong> <a href="https://www.belfercenter.org/person/nicholas-burns">https://www.belfercenter.org/person/nicholas-burns</a></p><blockquote><p>亲属</p></blockquote><p>侄子：  Ben Hutchins【 command of Marine Air Group 13 in Yuma,2019.08】（侄子本·哈钦斯上校（Ben Hutchins上校）为亚利桑那州尤马市的第13航空集团负责，现在指挥F-35和“ rier”式战斗机）</p><p>堂兄： 鲍勃·肯尼迪【Bob Kennedy  led the historic Mechanics Hall in Worcester for 12 years,2006-2018】<br><img src="https://gitee.com/merlynr/img-store/raw/master/202156/Dn-k1W_XoAEdMqu.jfif" alt="Dn-k1W_XoAEdMqu"></p><blockquote><p>哈佛</p></blockquote><p>助教： Philip Balson【哈佛大学，2019毕业】<br>菲利普·巴尔森</p><p><img src="https://gitee.com/merlynr/img-store/raw/master/202156/D1vTtnUWsAYtUFT.jfif" alt="菲利普·巴尔森"></p><p>Vince Lowney【研究助理文斯·洛尼2018.05毕业于哈佛，并于<strong>7月就任美国外交部</strong>】</p><p><img src="https://gitee.com/merlynr/img-store/raw/master/202156/Dd_uNA6W4AAsCyp.jfif" alt="Dd_uNA6W4AAsCyp"></p><p>Aditi Kumar 和 Chris Mirasola 2018.05毕业于哈佛</p><p><img src="https://gitee.com/merlynr/img-store/raw/master/202156/Dd-jdveXkAAu3TU.jfif" alt="Dd-jdveXkAAu3TU"></p><p>泰莎·亨利（Tessa Henry）和但丁·托波（Dante Toppo）2017.05毕业于哈佛</p><p><img src="https://gitee.com/merlynr/img-store/raw/master/202156/DAsbrBBXUAQoJcb.jfif" alt="DAsbrBBXUAQoJcb"></p><blockquote><p>组织@RedSox  —棒球俱乐部，没找到与之有关的报道</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> people </category>
          
      </categories>
      
      
        <tags>
            
            <tag> security </tag>
            
            <tag> people </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TagUI源码阅读及分析</title>
      <link href="2021/05/06/TagUI%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%8F%8A%E5%88%86%E6%9E%90/"/>
      <url>2021/05/06/TagUI%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%8F%8A%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>idea：</p><ol><li>RPA进程与AI的融合，非BPA那种与业务进行结合</li></ol><h3 id="tagui运行背后的技术支持"><a href="#tagui运行背后的技术支持" class="headerlink" title="tagui运行背后的技术支持"></a>tagui运行背后的技术支持</h3><p><img src="https://gitee.com/merlynr/img-store/raw/master/202156/1620314243708.png" alt="技术支持"></p><ol><li>Automation Flow:作为一种flow 编辑工具，集成在tagui中，允许TagUi可以通过本地文件，在线文件甚至url获取业务流程；</li></ol><ul><li>同时可以通过命令，图表，url，API，email等方式传入参数</li></ul><ol><li>Chrome Extension 可以通过类似录视频的方式记录用户行为并创建业务流程</li><li>R&amp;Python 提供机器学习模块</li><li>Sikuli 图像识别处理</li><li>CasperJS测试集成工具</li></ol><h3 id="关键技术组成"><a href="#关键技术组成" class="headerlink" title="关键技术组成"></a>关键技术组成</h3><ul><li>SikuliX 用于图像标记、追踪功能</li><li>phantomJs 是一种轻量级脚本语言（环境简单）</li><li>casperjs中基于PhantomJS和SlimerJS的导航脚本和测试工具，包函了对于一些对于网页的基本操作的工具<ul><li>SlimerJS与phantomjs类似，互相补充</li></ul></li></ul><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><ul><li>end_process: 通过扫描进程，按顺序杀死进程比Ctrl+C更加安全可靠</li><li>erina:==与tagui——helper有关，暂时无法看懂 #009688==</li><li>sleep: 补充win10环境中对于进程延迟的控制</li><li>tagui：TagUI接受脚本和参数</li><li>tagui_chrome: 用于连接chrome，通过控制浏览器发送和接收数据</li><li>tagui_crontab: 运行tagui服务端tagui_service</li><li>tagui_footer: 输出当前网站的url和title</li><li>tagui_global: ==暂时不懂 #009688==</li><li>tagui_header: ==作为一个工具包 #009688==</li></ul><h3 id="功能实现详细阐述"><a href="#功能实现详细阐述" class="headerlink" title="功能实现详细阐述"></a>功能实现详细阐述</h3><ol><li>监控对应任务进程进行杀死【php,chrome,sikuli,python,r,tagui】</li><li>sss</li><li>在Windows环境中无法进程设置延时，所以通过ping.exe补充功能</li><li>tagui框架入口源码交易理解，不做详细分析</li><li>tagui_chrome主要是依赖Textalk实现与chrome并发通信,同时它集成了Sikuli，可以通过图像识别实现业务流程</li><li>通过监控服务端状态，运行或者重复运行tagui_service</li><li>利用casperJs抓取当前脚本的url和title</li><li>sss</li><li>sss</li></ol><h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><p><a href="https://zhuanlan.zhihu.com/p/366304958">https://zhuanlan.zhihu.com/p/366304958</a><br><a href="https://github.com/kensoh/TagUI/tree/before_aisg">https://github.com/kensoh/TagUI/tree/before_aisg</a></p><h4 id="shell语言规范"><a href="#shell语言规范" class="headerlink" title="shell语言规范"></a>shell语言规范</h4><p><a href="https://www.cnblogs.com/zrmw/p/9625727.html">https://www.cnblogs.com/zrmw/p/9625727.html</a></p><p><a href="https://blog.csdn.net/weixin_37766087/article/details/99974385">https://blog.csdn.net/weixin_37766087/article/details/99974385</a></p><h4 id="curl工具"><a href="#curl工具" class="headerlink" title="curl工具"></a>curl工具</h4><p><a href="https://www.ruanyifeng.com/blog/2019/09/curl-reference.html">https://www.ruanyifeng.com/blog/2019/09/curl-reference.html</a></p><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p><a href="https://blog.csdn.net/shenhuan1104/article/details/75852822">https://blog.csdn.net/shenhuan1104/article/details/75852822</a></p><p>grep -iq 404 ，匹配到404，则返回1；反之</p><h4 id="业务流程模型（BPMN）"><a href="#业务流程模型（BPMN）" class="headerlink" title="业务流程模型（BPMN）"></a>业务流程模型（BPMN）</h4><h4 id="流程引擎"><a href="#流程引擎" class="headerlink" title="流程引擎"></a>流程引擎</h4><p>CasperJS + PhantomJS==》Puppeteer + Node.js引擎</p><p><a href="https://blog.csdn.net/qq_38941937/article/details/110296665">https://blog.csdn.net/qq_38941937/article/details/110296665</a></p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol><li>流式无并行</li></ol><h4 id="开题失败—-题目比较无实际意义"><a href="#开题失败—-题目比较无实际意义" class="headerlink" title="开题失败—-题目比较无实际意义"></a>开题失败—-题目比较无实际意义</h4><p><img src="./attachments/RPA动态感知分配业务资源的研究与应用.pptx" alt="RPA动态感知分配业务资源的研究与应用"></p>]]></content>
      
      
      <categories>
          
          <category> FrameWork </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> RPA </tag>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-04-12【Weekly】</title>
      <link href="2021/04/12/2021-04-05%E3%80%90Weekly%E3%80%91/"/>
      <url>2021/04/12/2021-04-05%E3%80%90Weekly%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h2 id="本周安排"><a href="#本周安排" class="headerlink" title="本周安排"></a>本周安排</h2><ul><li>[ ] MIT6.003要听四节课程</li><li>[x] 阅读并总结论文</li></ul><blockquote><p>Automated Discovery of Data Transformations for Robotic Process Automation</p></blockquote><ul><li>[x] 阅读 “Robotic Process Automation (RPA) and Security ”制定一份RPA系统配置计划书</li><li>[x] 完成RPA总结</li><li>[ ] 搭建实验室论坛</li><li>[ ] 完成小论文框架</li></ul><p><strong>后期补充</strong></p><ul><li>[x] 帮涛总完成数据库整理</li><li>[x] 确定基本RPA系统的组成</li></ul><h2 id="完成情况"><a href="#完成情况" class="headerlink" title="完成情况"></a>完成情况</h2><p><strong>任务完成</strong></p><ol><li>MIT6.003只听完第一节课，英语讲需要字幕反复听；</li><li>两篇论文，第一篇是关于RPA在进行文档操作过程中数据转换的改进，这篇还没有细读，后面细读一下、第二篇是关于RPA可能存在的问题，只是一篇综述，没有实际建议</li><li>RPA总结也初步完成，包括给那几个本科生讲了一下，就当时情况看，他们确实没有多少了解，几位同学可能还需要一些项目培养一下编码能力，可能需要更多努力来完成比赛，同时对于比赛题目的确定也需要多多了解RPA的应用场景</li><li>实验室论坛这块准备先让新来的师弟试试呀，和他交流过，他对于网络这块比较擅长，但是对于服务器这块比较欠缺，目前他和邹瑞学习，正好可以锻炼一下，如果后期没有完成，我再完成</li><li>目前研究点基本明确，只是缺少一个对于RPA研究下去信心，资料少，人少，学习内容多，工程大，确实需要先把UiPath搭建起来，并研究通了才能有信息继续研究下去</li><li>小论文这块想的是，本来学硕要求变难了，在平时学习过程中就开始填充知识，尽可能的跟上戴师兄和陈剑秋师兄的脚步</li><li>周五上午的数据整理初步完成，当时整理只是整理了部分，涛总也只是催了几个数据库的整理，后续情况等下次涛总安排吧</li><li>周六周日的时间，调研了一下UiPath的搭建，确定了基本的需求和流程，准备下周准备资源并进行搭建</li></ol><p><strong>学习方面</strong></p><blockquote><p>主要精力集中在RPA的总结上了，通过梳理几个大型公司的RPA产品，确定了目前比较热门以及将会被推广的产品有点：</p><ol><li>对于屏幕抓取的智能解决方案，通过AI自我修复流程，极低的降低了业务流程因因素抓取失败或因被其它相近元素干扰导致流程作业失败的机率</li><li>为用户提供一个可以用户可以自己训练AI的场景，让用户可以根据自己实际生产需求，训练出更符合自身的AI</li><li>视频录制业务流程，传统的录制由于对于元素的获取容易受到旁边元素干扰，而且对于未知问题处理能力极差，所有需要专门RPA开发员的，但是目前有个别公司推出了一个图像识别算法，大体意思是通过扫描页面元素树确定鼠标触碰元素，几乎达到无失误识别，同时加上AI修正流程功能，录制视频来创建业务流程的目的已经可以达到了。</li><li>还有一点是比较容易忽略的同时是很实际的，对于RPA的部署，本身RPA对于资源的消耗是比较大的，但是却是弹性的，所以比较难以控制RPA部署规模，有个别公司也提出了解决方案，就是，算法，bot，已经中台控制都是分开，分规模，分类别可选择的进行部署。</li></ol></blockquote><p> <strong>论文方面</strong></p><ol><li>RPA相关的论文，除了一些综述已经找不到其它有价值的了，下一步可能更多去一些公司的论坛进行查看了</li><li>目前有两个点，一个是，通过大量阅读和对于各个公司的观察，发现他们的重心都放在与AI的结合，扩展使用场景，却回避了RPA安全的严重缺陷，可能他们的场景是公司内网吧，所以第一个研究点就是RPA中的安全传输或者RPA中bot的数字认证；第二个是大点，还未确定可能与第一点，就是寻找一个应用场景，RPA需要与场景结合，通用性太高就容易导致研究</li><li><p>为RPA场景做准备，会阅读一些与人工智能相关的论文</p><h2 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h2><ol><li>学习资料已经只剩下框架的官方文档了，国内外的论文可以查到的都是一些综述了，后期只能查阅一些一些公司的讨论</li><li>对于UiPath的搭建进行了初步了解，RPA框架本身存在的问题就是无法容器化，这也是一个研究点，所以如果公司没用空的服务器，我只能在本地虚拟金进行尝试了，我今天在阿里云买了一个两核4G的服务器上进行搭建，发现内存不够，但是扩容需要钱太多了，就放弃了，下一步就在本地搭建RPA只能在本地进行尝试</li></ol><h2 id="后期安排"><a href="#后期安排" class="headerlink" title="后期安排"></a>后期安排</h2></li></ol><ul><li>[ ] 提出一个较为可操作的部署方案，并在本地进行尝试并总结</li><li>[ ] 了解一下市场需求，构思一个RPA隐患会造成极大破坏的场景，提出解决方案</li><li>[ ] 查阅一些公司的技术思路，了解一下他们在安全这块的研究点及解决方案，目前我总结的有几点：<ol><li>如何最大化的职责分配保障业务安全并最小的避免对业务流程的干扰</li><li>如何有效的进行身份认证和凭证的发放与验证</li><li>是否可以通过数据加密有效保证安全，还待考虑！<ol><li>日志监控这块研究一下，思路是构建一个日志记录追踪，类似微服务中的日志记录</li></ol></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> weekly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> weekly </tag>
            
            <tag> RPA </tag>
            
            <tag> plane </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPA</title>
      <link href="2021/03/28/what%E2%80%98s%20the%20mean%20of%20RPA/"/>
      <url>2021/03/28/what%E2%80%98s%20the%20mean%20of%20RPA/</url>
      
        <content type="html"><![CDATA[<h2 id="RPA"><a href="#RPA" class="headerlink" title="RPA"></a>RPA</h2><h3 id="进化历史"><a href="#进化历史" class="headerlink" title="进化历史"></a>进化历史</h3><ol><li>上个世纪二十年代 亨利·福特，改革了工业生产方式，开启了工业时代，提出了对于处理重复工作的需求</li><li>1990-2000，计算机被广泛使用，用于处理办公，提出批处理脚本和触发器</li><li>2000-2015，VBA宏编程（EXCEL宏）和BPA</li><li>2015-2018，RPA模型创建成功，并投入使用</li><li>2019~，RPA+AI，即RPA4.0被推出，被大企业认可</li></ol><p>1.2. 反应了为了解决重复工作，提出了批处理事务<br>脚本自动化：在RPA技术出现之前，脚本自动化是企业自动化可选的比较靠谱自动化落地技术。用于解决最基础的几步任务自动化，技术的缺点是没有容错、任务管理、弱鸡的基于GUI的能力。商业上的优势是，几乎可以免费使用。</p><ol><li>VBA编程语言的创建是为了解决办公中常遇到的重复性问题【简单化】、BPA（业务流程自动化）通过深度关注业务流程，集成所有相关应用程序来实现功能，业务的实现与程序耦合太重【复杂化】</li></ol><p>目前给出三个区别：<br><strong>集成</strong>：BPA相较于RPA对于一个业务流程提出了更加全面、更加精确的解决方法，但是BPA是一种侵入性很强的整合形式。它用自己的软件对现有的系统进行大修，并实现自己的系统。RPA不会破坏现有的业务流程。【存在优缺点】<br><strong>工作流</strong>：RPA机器人访问桌面现有的用户界面并执行人工任务，但是目前大多数机器人无法进行决策。BPA中使用的工作流程更加复杂，使用单一的处理模型来创建集成多种系统的工作流程。这些系统彼此交换和提取信息，以实现任务自动化，这需要API和数据库访问。这需要对编码和开发的大量IT支持。【应用场景的不同，无优缺点之分】<br><strong>定价</strong>：BPA定价取决于公司的规模。还有其涉及到的业务的规模。UiPath(RPA龙头企业)更加使用RPA类型来定价。【站在技术方面，RPA更加灵活，也更加适用】</p><ol><li>通过集成现有的业务不紧破坏了已有业务，同时过度的耦合、高昂的成本和无法普遍推广，这些条件都指定了传统化业务自动化流程只能为大公司所用。<br>这个时候屏幕抓取技术的诞生就突破了传统BPA的过度耦合的问题，它不需要过度依赖以前的业务来获取和处理数据，同时自动化与管理工具（管理系统的版本，安装，卸载等）使得RPA更易于推广，最后一个就是AI的加入，它是解放人类双手的核心，它可以根据人类先前的判断来执行任务。</li><li>RPA4.0的提出 我们不仅要看到AI为RPA提供的红利，同时也要看到RPA技术对于AI技术发展的重要意义，RPA为AI技术的发展提供了手和脚，RPA作为AI技术与现实生活的连接器，扩大了AI技术的使用范围</li></ol><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p>RPA的核心是通过自动化、智能化技术来“代替人”进行重复性、低价性、无需人工决策等固定性流程化操作，从而有效的提高工作效率，减少错误。</p><p>The main difference between software<br>robots and applications is the identity access<br>management (IAM) domain —  RPA instances<br>behave like an individual user. </p><h3 id="RPA进化四个阶段"><a href="#RPA进化四个阶段" class="headerlink" title="RPA进化四个阶段"></a>RPA进化四个阶段</h3><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021413/1618314304547.png" alt="四个阶段"></p><p>1：辅助性RPA（Assisted RPA）<br>　　在RPA 1.0阶段，作为“虚拟助手”出现的RPA，几乎涵盖了机器人自动化的主要功能，以及现有桌面自动化软件的全部操作。部署在员工PC机上，以提高工作效率。缺点则是难以实现端到端的自动化，成规模地应用还很难。<br>　　2：非辅助性RPA（Unassisted RPA）<br>　　在RPA 2.0阶段，被称为“虚拟劳动力”的RPA，主要目标即实现端到端的自动化，以及虚拟员工分级。主要部署在VMS虚拟机上，能够编排工作内容，集中化管理机器人、分析机器人的表现等。缺点则是对于RPA软件机器人的工作仍然需要人工的控制和管理。<br>　　3：自主性RPA（Autonomous RPA）<br>　　在RPA 3.0阶段，其主要目标是实现端到端的自动化和成规模多功能虚拟劳动力。通常部署在云服务器和SaaS上，特点是实现自动分级、动态负载平衡、情景感知、高级分析和工作流。缺点则是处理非结构化数据仍较为困难。<br>　　4：认知性RPA（Cognitive RPA）<br>　　RPA 4.0将是未来RPA发展的方向。开始运用人工智能、机器学习以及自然语言处理等技术，以实现非结构化数据的处理、预测规范分析、自动任务接受处理等功能。<br>　　目前，尽管大多数RPA软件产品，都还集中在2.0 - 3.0之间，但其发展已相当成熟，产品化程度亦是很高。一些行业巨头已经开始向RPA 4.0发起了探索。</p><h3 id="播放几个视频"><a href="#播放几个视频" class="headerlink" title="播放几个视频"></a>播放几个视频</h3><h3 id="扩展理解"><a href="#扩展理解" class="headerlink" title="扩展理解"></a>扩展理解</h3><p>轻量级IT，任何电子设备都可以被操控，<br>智能客服、智能家居，以及很多重复性较高、朝左流程固定的办公工作都可以被替代</p><h2 id="国内外现状"><a href="#国内外现状" class="headerlink" title="国内外现状"></a>国内外现状</h2><p>就国内外发展现状进行对比，全球五强RPA占有47%的市场，中国国产RPA目前智能更多被使用在能源、医疗、政务等一些领域。</p><h3 id="国内外"><a href="#国内外" class="headerlink" title="国内外"></a>国内外</h3><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021412/1618235359990.png" alt="国内外RPA"></p><p>国内主要厂商：来也科技、达观数据、云扩科技、艺赛旗、阿里云等<br>国外及世界领先的厂商：UiPath(免费社区版)、Blue Prism、Automation Anywhere</p><p>虽然国际RPA依旧扮演领导者和行业的规则的制定者，但是在各种新技术与RPA融合进程中，以及在生态建设成为RPA厂商主要竞争力的主流打法上，国产RPA并没有落后。甚至在一些方面，已经超越某些国外厂商。</p><p>可以通过近几年的融资金额和市场估值可以看出国产RPA也在蓬勃发展。</p><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021413/1618313802380.png" alt="2020年融资"></p><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021413/1618314424625.png" alt="近五年的投资事件"></p><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p><a href="https://zhuanlan.zhihu.com/p/275757075">https://zhuanlan.zhihu.com/p/275757075</a></p><h3 id="UiPath"><a href="#UiPath" class="headerlink" title="UiPath"></a>UiPath</h3><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021413/1618316991750.png" alt="UiPath服务器平台三层逻辑"></p><p>1）表示层<br>数据REST API端点<br>通知API<br>Web应用程序<br>2）Web服务层xiac<br>业务逻辑实现（下层为单个任务节点的实现提供服务，上层是bot根据任务队列，任务组成等多因素来控制任务执行）<br>3）持久层<br>弹性搜索<br>SQL服务器</p><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021413/1618317691754.png" alt="设计框架"></p><ol><li>开发人员在UiPath Studio中构建流程</li><li>使用Development Orchestrator和Quality Assurance Qrcheestrator对其进行测试；完成后，他们将工作流（未打包）签入uiatph中主UiProcess Library文件夹（在VCS上）</li><li>将工作流封装，并保存到QA，为本机专有使用</li><li>如果在测试期间发现任何问题，则重复上述步骤。</li><li>一旦所有的QA测试都通过了，包就被复制到生产环境（P包）</li><li>生产过程正在进行，由生产机器人运行</li></ol><ul><li><p>UiPath由studio（开发工具），Orchestrator（自动化云平台和监控平台），robot（运行已开发的机器人服务）组成</p></li><li><p>Robot分为Front Office Robot和Back Office Robot.缩写分别为FOR和BOR。 FOR需要手工启动。</p></li><li><p>BOR需要配合Orchestrator启动。</p></li><li><p>现在又分别叫Attended和Unattended：</p></li><li><p>Attended要有人照看，不能在电脑锁屏的状态下运行自动工作流</p></li><li><p>Unattended不用人工照看，可以在电脑锁屏的状态下运行自动工作流，由Orchestrator远程执行</p></li></ul><blockquote><p>Invokes Repository 调用（调用存储库）==公用部分，被多方调用 #00BCD4==<br>Reusable Code Library 可重用代码库</p></blockquote><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021413/1618320047098.png" alt="新版设计框架"></p><ul><li>提供免费社区版</li><li>产品线丰富，拓展了AI、process mining方面的能力</li><li>它提供了多种托管选项，例如云环境，虚拟机和终端服务</li><li>它支持各种Web和桌面应用程序</li><li>它支持自动登录功能来运行机器人</li><li>它包括可与 .Net，Java，Flash，PDF，Legacy，SAP配合使用的抓取解决方案，且准确性最高</li></ul><h3 id="阿里云RPA"><a href="#阿里云RPA" class="headerlink" title="阿里云RPA"></a>阿里云RPA</h3><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021413/1618321774264.png" alt="流程编辑器"></p><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021413/1618323038585.png" alt="整体结构"></p><p>阿里云RPA4.0采用主流C/S架构模式，前端客户端采用.net平台，基于Windows系统具有自主研发的SDK及各项功能，后端服务端采用Linux（CentOS）操作系统，提供各类后台服务和组件。</p><ul><li>对接阿里达摩院，NLP、OCR等人工智能能力深度整合，让机器人更智能</li><li>拥有丰富的SDK自动化模块，支持自定义SDK库</li><li>阿里云统一售后支持体系</li></ul><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021413/1618323129695.png" alt="场景"></p><h3 id="实在智能-章鱼数字员工"><a href="#实在智能-章鱼数字员工" class="headerlink" title="实在智能-章鱼数字员工"></a>实在智能-章鱼数字员工</h3><p>解决问题：</p><pre><code>- 用户可以根据自身需求指定AI套件- 通用AI能力精度不足</code></pre><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021415/1618463061303.png" alt="AaaS架构"></p><ol><li>RPA与算法平台进行无缝衔接</li></ol><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021415/1618463296265.png" alt="与算法平台衔接"></p><p>【视频—实在智能】</p><ol><li>集群以及AI定制</li></ol><blockquote><p>不同的系统对于计算能力，内容，硬盘以及网络的要求是不同的，可以根据系统不同分集群部署，不如算法运行在GPU上，而小型数据中台选择数据库服务器集群等；同时用户可以根据自身要求，选择算法和算法服务集群。</p></blockquote><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021415/1618463370738.png" alt="根据用户需求定制"></p><ol><li>算法开发训练</li></ol><blockquote><p>集成传统BPA的优势，为当前业务提供更加精确的算法</p></blockquote><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021415/1618463186299.png" alt="算法开发训练"></p><p><strong>产品优势：</strong></p><blockquote><p>北斗<em>**</em><br>1.传统的无锚点拾取，只能在简单场景<br>2.当页面中出现相同元素时通过附近元素进行判断并标识,选择不当容易导致流程失败<br>3.完全无感知的自动锚点选择，通过step-of-out图神经网络技术学习页面上的拓扑关系</p><p>神盾<br>通过监控流程，如果发生异常，则通过北斗自动修复元素来修正自动流程</p></blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzI2NjE2NjQ0Ng==&amp;mid=2247484934&amp;idx=1&amp;sn=d7d105996c81ac9af8a5567a6db799aa&amp;chksm=ea930fc7dde486d137d60d0a013db9d2f7390c0b3876da95a47ef8b0f17857fbab6fa40bd17b&amp;scene=21#wechat_redirect">开源框架</a></p><blockquote><p>魔镜</p></blockquote><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021415/1618464900207.png" alt="自动化开发"></p><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021415/1618464926504.png" alt="魔镜"></p><p>  目前各大公司对于RPA的使用多处于RPA2.0-RPA3.0之间，即需要RPA开发者介于，而魔镜这种通过视频与日志结合的开发模式将很大程度降低客户使用成本。</p><h3 id="框架总结"><a href="#框架总结" class="headerlink" title="框架总结"></a>框架总结</h3><p>RPA解决方案是依托于各类先进信息技术手段的虚拟劳动力，根据预先设定的程序操作指令对任务进行自动化处理，实现业务流程由机器人自动化处理。</p><p><strong>RPA能做的</strong></p><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021413/1618320374905.png" alt="可以满足我们的"></p><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021413/1618323364197.png" alt="新的行业标准"></p><ol><li>作为辅助甚至代替传统职工的工作软件，它需要员工的权限，但是却又脱离了系统的安全保障，这就造成了安全危机。<br>任子旭的对于网络安全和内部合规的提议：<br>对网络安全和内控合规的要求和约束时，主要是两个思路：<strong>遵从和自证清白</strong>。</li></ol><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021413/1618320690337.png" alt="保障安全"></p><ol><li>作为一个辅助软件，本身高效性的前提是与相对应的工作量对照的，这就需要在配置时根据公司业务量来取舍，防止资源被浪费</li><li>虚拟化和环境一致性。整个项目的交付过程中，并没有那么简单。我们要考虑空间环境、系统环境、程序适用、版本兼容等多个因素。</li></ol><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021413/1618320927712.png" alt="部署中的注意点"></p><h2 id="研究内容"><a href="#研究内容" class="headerlink" title="研究内容"></a>研究内容</h2><p>RPA到底可以发展到什么程度？</p><h3 id="可研究点"><a href="#可研究点" class="headerlink" title="可研究点"></a>可研究点</h3><h4 id="RPA-网络安全风险"><a href="#RPA-网络安全风险" class="headerlink" title="RPA 网络安全风险"></a>RPA 网络安全风险</h4><ol><li>滥用特权访问</li></ol><ul><li>攻击者可能能够危及机器人使用的管理员帐户。攻击者可以使用管理员帐户获得对敏感数据的访问权限</li><li>在离职之前，前员工可以编程机器人删除重要数据并中断业务流程</li></ul><ol><li>披露敏感数据</li></ol><ul><li>机器人开发人员可能会错误地编写BOT，以将高机密数据（例如信用卡信息）上传到公众通过Web访问的数据库。</li><li>机器人开发人员可以使用他或她的账户窃取业务其他服务信息</li></ul><ol><li>安全漏洞</li></ol><ul><li>虚拟机环境中可能存在安全漏洞，这是机器人运行的环境。</li><li>机器人开发人员编程机器人发送/接收敏感数据而不加密。此数据很脆弱，可以由攻击者利用</li></ul><ol><li>拒绝服务</li></ol><ul><li>一些不良的编程实践可以使机器人消耗所有虚拟机系统资源并导致虚拟机变得无响应，因此无法执行任何工作</li><li>虚拟机可能受到计划受到计划升级或网络维护的影响，可能导致中断损失。</li></ul><p><strong>应对策略</strong></p><ol><li>先进的职责分工，这就限制RPA用户只能执行分配给分配的任务，并且它们没有提升访问权限。同时也要限制代码开发人员与使用者的行为。</li></ol><p><img src="https://gitee.com/merlynr/img-store/raw/master/2021414/1618390329616.png" alt="主要RPA角色"></p><ol><li>数字身份认证和凭证的发放与验证，大部分黑客攻击都是在凭据被损害后发起的。为了避免这种情况，就需要设置机器人为最小的特权角色，那么机器人只能执行它的设计，并且其用户角色不能用于执行其他功能</li><li>数据加密，保证数据在传输过程前被加密，以及作业完成后删除。</li><li>监视日志并在内部控件损坏时执行审计，机器人活动可用于监测异常行为并进行审计，以防问题存在问题。</li><li>在发布生产代码之前，需要先扫描代码的漏洞，可以通过一些工具实现，Dynamic Application Security Testing (DAST) 【动态应用安全测试】and Fortify. </li></ol><h4 id="业务流程转型，RPA部署的效率、评估和解决方案"><a href="#业务流程转型，RPA部署的效率、评估和解决方案" class="headerlink" title="业务流程转型，RPA部署的效率、评估和解决方案"></a>业务流程转型，RPA部署的效率、评估和解决方案</h4><h4 id="对于其他功能的聚合，如应用控制，OCR-桌面自动化，中央管理等"><a href="#对于其他功能的聚合，如应用控制，OCR-桌面自动化，中央管理等" class="headerlink" title="对于其他功能的聚合，如应用控制，OCR,桌面自动化，中央管理等"></a>对于其他功能的聚合，如应用控制，OCR,桌面自动化，中央管理等</h4><h4 id="分区平台的共享服务必然会被需求较小的公司需求"><a href="#分区平台的共享服务必然会被需求较小的公司需求" class="headerlink" title="分区平台的共享服务必然会被需求较小的公司需求"></a>分区平台的共享服务必然会被需求较小的公司需求</h4><h4 id="跨平台的应用操作能力"><a href="#跨平台的应用操作能力" class="headerlink" title="跨平台的应用操作能力"></a>跨平台的应用操作能力</h4><h4 id="容器化"><a href="#容器化" class="headerlink" title="容器化"></a>容器化</h4><h4 id="RPA开发运维"><a href="#RPA开发运维" class="headerlink" title="RPA开发运维"></a>RPA开发运维</h4><p>从软件供应商转变为服务供应商<br>在共享服务中，自动化会变得极其慢，集群</p><h3 id="后期安排"><a href="#后期安排" class="headerlink" title="后期安排"></a>后期安排</h3><p>UiPath、tensorFlow</p>]]></content>
      
      
      <categories>
          
          <category> RPA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> RPA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-03-26【周总结】</title>
      <link href="2021/03/24/2021-03-24%E3%80%90Week%E3%80%91/"/>
      <url>2021/03/24/2021-03-24%E3%80%90Week%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h2 id="本周安排"><a href="#本周安排" class="headerlink" title="本周安排"></a>本周安排</h2><ul><li>[ ]  MIT6.004课程完成</li><li>[x] 学位英语</li><li>[ ] 继续查询项目依赖bug</li><li>[x] 查询论文，并阅读总结两篇</li><li>[x] openRPA实例实现</li></ul><h2 id="完成情况"><a href="#完成情况" class="headerlink" title="完成情况"></a>完成情况</h2><blockquote><p>主要精力放在学位英语上了，后期学习了部分MIT6003的课程，以及最后研究了openRPA的使用</p></blockquote><p><strong>论文方面</strong></p><pre><code>    与openRPA技术相关的论文还是没有查阅到，只是查阅了一些综述以及国内外对于RPA预测的推文，现在归纳了三个可研究点：</code></pre><ol><li>RPA机器人在运行时一般需要最高权限，这就可能引起黑客的攻击直接让过传统权限控制系统，通过直接攻击黑客来攻击系统</li><li>找到一个适合的场景，做RPA+AI，类似文本、语音、或者直接获取通讯记录来给RPA传输指令，这个研究点是目前比较常被提到的RPA4.0</li><li>RPA缺乏对于未知问题的解决能力，这个点预计很难研究，这是一个普遍问题</li></ol><p><strong>个人课程学习</strong></p><blockquote><p>空间技术课程提到一个“社会计算”，这个是杨老师他们大实验的学长有过研究就是给我们科普了一下，不过李波老师提到了他们大实验室有个好的idea就是搭建一个实验室的微服务系统，然后把每届的研究成果数据都放上去，以方便给后几届学弟学妹使用，老师我觉得我们实验室与师兄师姐交流太少了，而且他们也很忙几乎没有空和我们交流，这个idea也可以实现在我们实验室，对于学生提供了一个很好的学习见解。</p></blockquote><p><strong>公司方面</strong></p><blockquote><p>每周没有任务跟进，后期会对公司依赖bug进行查询补充</p></blockquote><h2 id="下周安排"><a href="#下周安排" class="headerlink" title="下周安排"></a>下周安排</h2><ul><li>[ ] 根据已经发现的RPA研究点中的第一个小点进行查阅论文并总结</li><li>[ ] 今天对openRPA进行了初步阅读，发现openRPA是C#的项目，本身没有学习过，会花两到三天进行学习C#语言，然后阅读源码</li><li>[ ] 继续学习MIT6003课程</li><li>[ ] 补充公司项目依赖部分bug</li><li>[ ] 每天尽量听会英语课程</li></ul>]]></content>
      
      
      <categories>
          
          <category> weekly report </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> report </tag>
            
            <tag> study </tag>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-3-19【周总结】</title>
      <link href="2021/03/19/2021-3-19%E3%80%90%E5%91%A8%E6%80%BB%E7%BB%93%E3%80%91/"/>
      <url>2021/03/19/2021-3-19%E3%80%90%E5%91%A8%E6%80%BB%E7%BB%93%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h2 id="本周安排"><a href="#本周安排" class="headerlink" title="本周安排"></a>本周安排</h2><ul><li>[x] 熟悉OpenRPA框架</li><li>[x] 通过代码实操学习对数据库的操作</li><li>[x] 阅读相关论文—流程机器人+AI</li><li>[x] 做网络安全课程PPT</li><li>[x] 英语学习</li><li>[ ] 对比五个框架，并总结</li></ul><h2 id="后加入的任务"><a href="#后加入的任务" class="headerlink" title="后加入的任务"></a>后加入的任务</h2><ol><li>帮助公司接口优化整理项目依赖资料</li><li>完成部分公司项目依赖版本与最新版之间错误的总结</li></ol><h2 id="完成情况"><a href="#完成情况" class="headerlink" title="完成情况"></a>完成情况</h2><blockquote><p>本周主要主要精力集中于论文、学习实操了一些mabtis代码后面有花费了不到两天整合公司项目依赖相关材料,五个框架没有整理太多。</p></blockquote><p><strong>论文方面：</strong></p><pre><code>观看了为了“提出轻量级IT程序与自动化流程集成的规范化”的论文和The Forrester Wave™2018年发表的RPA总结汇报。</code></pre><p>1、第一篇中详细阐明RPA中的轻量IT的使用场景，规则以及与传统系统的区别，更加容易明白轻量IT在自动化流程中的作用，加深了对于RPA的理解——-只要有载体可以实现所有人的行为【可能一开始从五个框架入手，被局限于自动化测试了】<br>2、第二篇从报告中了解较为认可的15个成熟的框架，以及这个报告详细阐述了RPA评定的规则</p><p><strong>个人课程学习</strong></p><ul><li>加深了在小论文方面的学习</li><li><p>对于小论文的发表有了基本的概念，现在加强论文方面阅读，寻找该方向研究点</p><p><strong>公司方面</strong></p><ul><li>主要参与负责总结公司项目依赖版本以及总结公司当前版本的无法修补的bug情况。前期基本完成，后期由于工作量比较大，完成了部分，我问了实验室其它人，他们说好像优化完成了，涛总也没问过我了，后期的bug调研就没有跟进了</li></ul></li></ul><h2 id="下周安排"><a href="#下周安排" class="headerlink" title="下周安排"></a>下周安排</h2><ol><li>先将2018的年度关于RPA总结报告看完，理解RPA的评定规范</li><li>详细阅读OpenRPA源码，总结优缺点</li><li>查询与RPA相关的AI算法，扩展学习</li><li>将英语学习提上日常，每天背后单词，练下口语</li><li>不能放下代码能力，依旧进行少量代码实操</li></ol>]]></content>
      
      
      <categories>
          
          <category> weekly report </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> report </tag>
            
            <tag> study </tag>
            
            <tag> weekly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五个RPA框架通读</title>
      <link href="2021/02/22/%E4%BA%94%E4%B8%AARPA%E6%A1%86%E6%9E%B6%E9%80%9A%E8%AF%BB/"/>
      <url>2021/02/22/%E4%BA%94%E4%B8%AARPA%E6%A1%86%E6%9E%B6%E9%80%9A%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="Robot-Framework"><a href="#Robot-Framework" class="headerlink" title="Robot Framework"></a>Robot Framework</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li>接受测试驱动开发（ATDD），行为驱动开发（BDD）和机器人流程自动化（RPA）</li><li><a href="https://robotframework.org/#examples">社区</a></li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><blockquote><p>Robot Framework的环境搭建</p></blockquote><ol><li>安装wxpython需要安装wheel，不然无法打包安装======</li><li>需要安装与chrome版本匹配的driver到目录中</li></ol><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><ol><li>通过代码来进行生产</li></ol><ul><li>项目组成</li></ul><p><img src="https://gitee.com/merlynr/img-store/raw/master/202136/1615015210514.png" alt="项目组成"></p><blockquote><p>项目见压缩文件—-项目一，下面是robot的代码结构组成</p></blockquote><p><a href="https://github.com/robotframework/QuickStartGuide/blob/master/QuickStart.rst#executing-this-guide">参考文档</a></p><p>robot核心结构是由三部分组成的，一个是keywords的依赖，第二个是关键字，最后则是执行动作</p><p><img src="https://gitee.com/merlynr/img-store/raw/master/202136/1615015362634.png" alt="robot结构"></p><p><img src="https://gitee.com/merlynr/img-store/raw/master/202136/1615015469911.png" alt="关键字组成"></p><p><img src="https://gitee.com/merlynr/img-store/raw/master/202136/1615015588995.png" alt="动作"></p><p>运行效果，打包视频-robot1【视频总一个robot执行了两动作，所以结果都是两个】</p><p><img src="./videos/robot1.mkv" alt="robot1"></p><ol><li>通过较为成熟的工具—robocorp Lab</li></ol><p>==此工具可以实现的，robot framework都可以实验 #009688==</p><ul><li>结构组成</li></ul><p><img src="https://gitee.com/merlynr/img-store/raw/master/202136/1615016378239.png" alt="项目结构"></p><p><img src="https://gitee.com/merlynr/img-store/raw/master/202136/1615016399861.png" alt="robot结构"></p><ul><li>较为简单的栗子，自动打开浏览器然后访问url</li></ul><p><img src="./videos/robocorp1.mkv" alt="robocorp1"></p><ul><li>另一个栗子，登录功能的测试</li></ul><p><img src="./videos/robocorp2.mkv" alt="robocorp2"></p><blockquote><p>总结：和邹瑞进行过交流确实这个框架确实可以提升测试效率，由于执行动作可以通过传参来改变动作执行对象，所以可重复度明显提升，目前没有感觉到人工智能的应用点，下步继续了解。</p></blockquote><h2 id="TagUI"><a href="#TagUI" class="headerlink" title="TagUI"></a>TagUI</h2><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><pre><code>    就是传统的，较为灵活但是复用性低；这个框架可以控制鼠标模拟动作</code></pre><p><img src="https://gitee.com/merlynr/img-store/raw/master/202136/1615018851173.png" alt="代码结构"></p><h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><ol><li><p>访问网站并截图</p><p> <img src="https://gitee.com/merlynr/img-store/raw/master/202136/1615019129522.png" alt="源码"></p></li></ol><p><img src="./videos/tagui_1.mkv" alt="tagui_1"></p><p>==tagui在模拟人的行为上确实比robot framework #00BCD4==</p><ol><li>访问github上项目并下载等待完成</li></ol><p><img src="./videos/tagui_2.mkv" alt="tagui_2"></p><ol><li><p>可以通过表格来设置参数，高重复性</p><p><img src="./videos/tagui_3.mkv" alt="tagui_3"></p><pre><code>   还有一些官方也提到可以获取数控中数据来进行测试，也可以通过中文命令来测试等</code></pre></li></ol><h2 id="UI-Vision"><a href="#UI-Vision" class="headerlink" title="UI.Vision"></a>UI.Vision</h2><blockquote><p>有两个，一个是浏览器插件，另一个是桌面版。桌面版适用于手机上app的测试【没有进行实验】</p></blockquote><p><img src="./videos/2021-03-06_17-29-08.mkv" alt="2021-03-06 17-29-08"></p><p>总结：很傻瓜式，所有动作需要一模一样，否则无法找到指定的属性来换参，前面有一点不一样，后面将可能无法执行。</p><h2 id="open-RPA"><a href="#open-RPA" class="headerlink" title="open RPA"></a>open RPA</h2><p><a href="https://open-rpa.readthedocs.io/en/latest/">https://open-rpa.readthedocs.io/en/latest/</a></p><p><a href="https://docs.openiap.io/">https://docs.openiap.io/</a></p>]]></content>
      
      
      <categories>
          
          <category> RPA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> RPA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式复习-2</title>
      <link href="2021/01/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%8D%E4%B9%A0-2/"/>
      <url>2021/01/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%8D%E4%B9%A0-2/</url>
      
        <content type="html"><![CDATA[<h1 id="里氏替换原则（Liskov-Substitution-Principle，LSP）"><a href="#里氏替换原则（Liskov-Substitution-Principle，LSP）" class="headerlink" title="里氏替换原则（Liskov Substitution Principle，LSP）"></a>里氏替换原则（Liskov Substitution Principle，LSP）</h1><h2 id="爱恨纠葛的父子关系—-继承"><a href="#爱恨纠葛的父子关系—-继承" class="headerlink" title="爱恨纠葛的父子关系—-继承"></a>爱恨纠葛的父子关系—-继承</h2><p><strong>优点：</strong></p><ol><li>代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性；</li><li>提高代码的重用性；</li><li>子类可以形似父类，但又异于父类，“龙生龙，凤生凤，老鼠生来会打洞”是说子拥有父的“种”，“世界上没有两片完全相同的叶子”是指明子与父的不同；</li><li>提高代码的可扩展性，实现父类的方法就可以“为所欲为”了，君不见很多开源框架的扩展接口都是通过继承父类来完成的；</li><li><p>提高产品或项目的开放性</p><p><strong>缺点：</strong></p><ol><li>继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法；</li><li>降低代码的灵活性。子类必须拥有父类的属性和方法，让子类自由的世界中多了些约束；</li><li>增强了耦合性。当父类的常量、变量和方法被修改时，需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大段的代码需要重构。</li></ol><blockquote><p>“利”大于弊，发挥利的最大作用。</p></blockquote></li></ol><p><strong>What‘s mwan LSP?</strong><br>最正宗的定义：If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.（如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型。）<br>最清晰明确的：Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的对象。）通俗点讲，<font color="#86AECE">只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。</font></p>]]></content>
      
      
      <categories>
          
          <category> exam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> exam </tag>
            
            <tag> design-model </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高级软件考试准备---研究生</title>
      <link href="2021/01/03/%E9%AB%98%E7%BA%A7%E8%BD%AF%E4%BB%B6%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87---%E7%A0%94%E7%A9%B6%E7%94%9F/"/>
      <url>2021/01/03/%E9%AB%98%E7%BA%A7%E8%BD%AF%E4%BB%B6%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87---%E7%A0%94%E7%A9%B6%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="考试内容"><a href="#考试内容" class="headerlink" title="考试内容"></a>考试内容</h1><ol><li>面向对象</li></ol><ol><li>六大原则</li></ol><ul><li>单一职责原则</li><li>里氏替换原则</li><li>依赖倒置原则</li><li>接口隔离原则</li><li>迪米特法则</li><li>关闭原则</li></ul><ol><li>主讲了九个模式一个机制</li></ol><ul><li>策略</li><li>观察[主动or被动]</li><li>工厂，抽象工厂</li><li>装饰</li><li>建造</li><li>组合</li><li>外观</li><li>状态</li><li>适配</li><li>反射机制</li></ul><p><img src="https://gitee.com/merlynr/img-store/raw/master/202113/高软复试材料.jpg" alt="往年考试题"></p><h1 id="分数占比分析"><a href="#分数占比分析" class="headerlink" title="分数占比分析"></a>分数占比分析</h1><blockquote><p>概念:模式设计 = 六四开</p><font color="red">抓好概念，模式设计这些言之有理即可</font></blockquote><h1 id="复习记录"><a href="#复习记录" class="headerlink" title="复习记录"></a>复习记录</h1><h2 id="程序设计方法基础"><a href="#程序设计方法基础" class="headerlink" title="程序设计方法基础"></a>程序设计方法基础</h2><ol><li>传统分层</li></ol><p>划分方式： 物理/逻辑<br>层数：两/三层</p><ol><li>逻辑上的三层结构</li></ol><ul><li>显示层View/UI（User Interface)</li><li>业务逻辑层BLL（Business Logic Layer）</li><li>数据访问层DAL（Data Access Layer）</li></ul><ol><li>原则，目的，优点</li></ol><p>分层访问<strong>原则</strong>：不可跨层进行访问、当前层只处理该职责的业务<br><strong>目的</strong>：隔离/解耦合<br><strong>优点</strong>：可维护性/扩展性/性能/安全性/</p><h2 id="面向对象方法的引入"><a href="#面向对象方法的引入" class="headerlink" title="面向对象方法的引入"></a>面向对象方法的引入</h2><ol><li>推广原因</li></ol><p><strong>为了解决块间的同名变量冲突，就会在编程中进行封装（保护）的尝试</strong>，对封装的进一步发展就提出了对象的概念，并增加了类，类继承的概念。、</p><ol><li>那么如何度量派生继承是良好的呢？</li></ol><p><strong>存在问题</strong>：代码的重用性和可扩展性都大大提升了，但是也带来了强耦合</p><blockquote><p><font color="#FF726A">LSP</font>：Liskov Substitution Principle<br>里氏原则可度量继承关系的质量，是面向对象的重要基石，该原则使得软件的功能扩展成为可能。</p></blockquote><ul><li>向下兼容思想【高版本可以打开低版本，子类可以透明替代父类，反之则否】</li></ul><p>如何满足向下兼容，且可扩展？<br>功能模块的<strong>可修改性</strong>，即程序中函数的调用不是在编译的时候确定，而是在运行时刻被确定的。</p><p><img src="https://gitee.com/merlynr/img-store/raw/master/202113/1609667788985.png" alt="虚函数"></p><p><em>c++的虚基类用在控制重复继承上，表示这个基类在实例化子类时只生成一个副本 java只能单继承，不存在重复继承</em></p><ol><li>面向对象的特性</li></ol><ul><li>抽象(Abstraction)</li><li>封装(Encapsulation)</li><li>继承派生(Inheritance)</li><li>多态(Polymorphism)</li><li><p>组合(Composition)</p><ol><li>面向对象引入的目的</li></ol></li><li><p>重用（Reuse：Inheritance &amp; composition）</p></li><li>统一接口（Unified interface）</li><li>适用变化（Adapt to Change of Request）</li></ul>]]></content>
      
      
      <categories>
          
          <category> exam </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> study </tag>
            
            <tag> exam </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式复习-1</title>
      <link href="2020/12/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%8D%E4%B9%A0-1/"/>
      <url>2020/12/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%8D%E4%B9%A0-1/</url>
      
        <content type="html"><![CDATA[<h1 id="辅助工具学习"><a href="#辅助工具学习" class="headerlink" title="辅助工具学习"></a>辅助工具学习</h1><h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><p><a href="http://www.cleey.com/blog/single/id/873.html">源头</a></p><p><img src="https://gitee.com/merlynr/img-store/raw/master/20201228/1609158745582.png" alt="栗子"></p><ol><li>车的类图结构为&lt;&gt;，表示车是一个抽象类； </li><li>它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用 带空心箭头的虚线表示； </li><li>小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示； </li><li>小汽车与发动机之间是组合关系，使用带实心箭头的实线表示； </li><li>学生与班级之间是聚合关系，使用带空心箭头的实线表示； </li><li>学生与身份证之间为关联关系，使用一根实线表示； </li><li>学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示；</li></ol><h3 id="详细学习"><a href="#详细学习" class="headerlink" title="详细学习"></a>详细学习</h3><p> <strong>泛化关系(Generalization)</strong></p><blockquote><p>【泛化关系】：是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。</p></blockquote><p><em>继承关系为 is-a</em></p><p><img src="https://gitee.com/merlynr/img-store/raw/master/20201228/1609159498467.png" alt="A继承自B"></p><pre><code>【代码体现】：表现为继承非抽象类</code></pre><p><strong>实现关系(Realization)</strong></p><blockquote><p>【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现.</p></blockquote><p><img src="https://gitee.com/merlynr/img-store/raw/master/20201228/1609159705360.png" alt="实现关系表现为继承抽象类"></p><pre><code>【代码体现】：表现为继承抽象类</code></pre><p><strong>聚合关系(Aggregation)</strong></p><blockquote><p>【聚合关系】：是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。</p></blockquote><p>  <em>聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。【箭头及指向】：带空心菱形的实心线，菱形指向整体</em></p><p>  <img src="https://gitee.com/merlynr/img-store/raw/master/20201228/1609159862416.png" alt="表示A聚合到B上，或者说B由A组成"></p><p> <em>聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成；<br>与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在</em></p><pre><code>【代码体现】：成员变量</code></pre><p><strong>组合关系(Composition)</strong></p><blockquote><p>【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。</p></blockquote><p><img src="https://gitee.com/merlynr/img-store/raw/master/20201228/1609159977459.png" alt="A组成B，或者B由A组成">  </p><pre><code>【代码体现】：成员变量</code></pre><p><strong>关联关系(Association)</strong></p><blockquote><p>【关联关系】：是一种拥有的关系，它使一个类知道另一个类的属性和方法。</p></blockquote><p><em>老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。</em></p><p><img src="https://gitee.com/merlynr/img-store/raw/master/20201228/1609160265231.png" alt="【箭头及指向】：指向被拥有者"></p><p><img src="https://gitee.com/merlynr/img-store/raw/master/20201228/1609160313507.png" alt="自身关联"></p><pre><code>【代码体现】：成员变量</code></pre><p><strong>依赖关系(Dependency)</strong></p><blockquote><p>【依赖关系】：是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖.</p></blockquote><p><img src="https://gitee.com/merlynr/img-store/raw/master/20201228/1609160418902.png" alt="【箭头及指向】：指向被使用者"></p><p><em>与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化； 依赖关系也可能发生变化；</em></p><font color="red">依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生；</font><pre><code>【代码表现】： 局部变量、方法的参数或者对静态方法的调用</code></pre><h3 id="疑惑与解答"><a href="#疑惑与解答" class="headerlink" title="疑惑与解答"></a>疑惑与解答</h3><blockquote><p>问题来了小汽车是车的实现，那么SUV本身也是小汽车的实现呀，为何这归为泛化？</p></blockquote><p><strong>答：</strong> 泛化关系表现为继承非抽象类,(可以查看上边实现关系与泛化关系的定义)</p><h1 id="设计模式之禅"><a href="#设计模式之禅" class="headerlink" title="设计模式之禅"></a>设计模式之禅</h1><p><a href="https://gitee.com/merlynr/img-store/blob/d1481813922e92a8e297194f2c8176aab822be66/resource/e-book/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89.pdf">感谢秦小波大佬的开阔前路</a></p><h2 id="大旗不挥，谁敢冲锋——6大设计原则全新解读"><a href="#大旗不挥，谁敢冲锋——6大设计原则全新解读" class="headerlink" title="大旗不挥，谁敢冲锋——6大设计原则全新解读"></a>大旗不挥，谁敢冲锋——6大设计原则全新解读</h2><h3 id="单一职责原则Single-Responsibility-Principle—SRP"><a href="#单一职责原则Single-Responsibility-Principle—SRP" class="headerlink" title="单一职责原则Single Responsibility Principle—SRP"></a>单一职责原则Single Responsibility Principle—SRP</h3><blockquote><p>单一职责原则的定义是：应该<font color="red">有且仅有一个</font>原因引起类的变更</p></blockquote><p><strong>SRP</strong> :There should never be more than one reason for a class to change.</p><p>文中作者举了个打电话的例子，电话通话的时候有4个过程发生：拨号、通话、回应、挂机四步骤。</p><p><img src="https://gitee.com/merlynr/img-store/raw/master/20201228/1609163346475.png" alt="电话类图"></p><p><img src="https://gitee.com/merlynr/img-store/raw/master/20201228/1609163496643.png" alt="代码清单"></p><p>这是目前比较正常的做法，面向接口编程。作者认为这个接口接近<em>完美</em> 但是却没有SRP，一个接口或者类只有一个原因引起变化。细谈打电话这个栗子，打电话这个接口不只一个职责，作者将其 分为两个，一个是底层数据交互时的<strong>协议管理</strong>，另一个是<strong>数据传输</strong>。dial()和hangup()两个方法实现的是协议管理，分别负责通过协议拨号接通和挂机；chat()实现的是数据的传送。</p><p><img src="https://gitee.com/merlynr/img-store/raw/master/20201228/1609163747222.png" alt="职责分明的电话类图"></p><p>于是根据SRP，实现了上图的设计。但是一个手机类要把ConnectionManager和DataTransfer组合在一块才能使用。<strong>组合</strong>是一种强耦合关系，你和我都有<strong>共同的生命期</strong>，这样的强耦合关系还不如使用接口实现的方式呢，而且还增加了类的复杂性，多了两个类。经过这样的思考后，我们再修改一下类图，如图。</p><p><img src="https://gitee.com/merlynr/img-store/raw/master/20201228/1609164425134.png" alt="简洁清晰、职责分明的电话类图"></p><p>这个设计实现了一个类实现两个接口，把两个职责融合到一块。这个已经符合SRP，一个协议控制的责任，一个数据传输的协议，但是和我理解的不一样，为什么定义说的是类呢?，那么就需要重新理解了，<font color="red">什么是SRP呢？</font></p><p><font color="green">答:</font> 实现最小责任的面向接口编程。<font color="#86AECE">这里的接口只是因为我们现在编程的习惯将功能与接口相对应，所以我们也需要考虑类是否满足最小责任，甚至方法。。。</font>，这就需要我们将“责任”和“变化原因”纳入衡量接口或类的质量考量范畴了。</p><blockquote><p>与当前编程环境相结合：</p><ol><li>不可强行SRP，这样就会是很多功能被强行拆分，然后使用时通过大量聚合和组合耦合在一块，无疑增加了系统复杂性</li><li>国内各个公司普遍开发环境还是面向对象开发，即一个对象的所以动作，都抽象到一个接口中例如图1-1，但是我们已经尽可能的实现SRP，例如图1-2</li></ol></blockquote><p><img src="https://gitee.com/merlynr/img-store/raw/master/20201228/1609166170558.png" alt="图1-1"></p><p><img src="https://gitee.com/merlynr/img-store/raw/master/20201228/1609166184445.png" alt="图1-2"></p>]]></content>
      
      
      
        <tags>
            
            <tag> study </tag>
            
            <tag> design-model </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Towards developing a secure medical image sharing system based on zero trust principles and blockchain technology</title>
      <link href="2020/12/24/Towards%20developing%20a%20secure%20medical%20image%20sharing%20system%20based%20on%20zero%20trust%20principles%20and%20blockchain%20technology/"/>
      <url>2020/12/24/Towards%20developing%20a%20secure%20medical%20image%20sharing%20system%20based%20on%20zero%20trust%20principles%20and%20blockchain%20technology/</url>
      
        <content type="html"><![CDATA[<p><a href="https://gitee.com/merlynr/img-store/blob/d1481813922e92a8e297194f2c8176aab822be66/resource/paper/%E8%87%B4%E5%8A%9B%E4%BA%8E%E5%BC%80%E5%8F%91%E5%9F%BA%E4%BA%8E%E9%9B%B6%E4%BF%A1%E4%BB%BB%E5%8E%9F%E5%88%99%E5%92%8C%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AE%89%E5%85%A8%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E5%85%B1%E4%BA%AB%E7%B3%BB%E7%BB%9F/paper.pdf">论文</a></p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ol><li>The traditional hospital network framework is very fragile in the era when it needs to be partially opened up.传统医院网络框架在现在需要部分开放的时代显得十分脆弱</li><li>Proper security measures have not been taken around the internal instruments of the hospital, they are easy to be manipulated and tampered with, and the data sources are extremely vulnerable to persecution.—医院内部仪器周围没有采取适当的安全措施，它们很容易被操控和篡改，数据源极易受到迫害。</li><li>Electronic medical records have become a trend to preserve the results of medical treatment, so it is necessary not only to ensure the safety of medical records, but also to ensure the security in the process of transmission.—电子病历已经成为一种保存治病结果的趋势，那么不仅要保障病历保存的安全，还要保证传输过程中的安全。</li></ol><p>Data security has been a critical topic of research and discussion since the onset of data sharing in e-health systems.The traditional hospital network mostly adopts the construction mode of multiple sets of network connection isolation, such as internal network, external network, intelligent private network and so on.The traditional hospital network architecture relies too much on physical isolation, with the popularity of electronic medical system, which requires its network to be partially open to the outside world, and the vulnerability of its network architecture is infinitely magnified, which can be easily broken by hackers.—传统医院网络架构过度依赖物理隔离，随着电子医疗系统普及，这就要求它的网络对外部分开放，它网络架构的脆弱性就被无限放大，黑客很容易就可以攻破。</p><h3 id="Preliminary-Knowledge"><a href="#Preliminary-Knowledge" class="headerlink" title="Preliminary Knowledge"></a>Preliminary Knowledge</h3><p><strong>Zero trust reference architecture</strong></p><p><img src="https://gitee.com/merlynr/img-store/raw/master/20201224/1608811874254.png" alt="零信任框架的关键能力模型"></p><p>零信任的本质是在访问主体和客体之间构建以身份为基石的动态可信访问控制体系，通过以身份为基石、业务安全访问、持续信任评估和动态访问控制的关键能力，基于对网络所有参与实体的数字身份，对默认不可信的所有访问请求进行加密、认证和强制授权，汇聚关联各种数据源进行持续信任评估，并根据信任的程度动态对权限进行调整，最终在访问主体和访问客体之间建立一种动态的信任关系。</p><h3 id="System-Model"><a href="#System-Model" class="headerlink" title="System Model"></a>System Model</h3><p><img src="https://gitee.com/merlynr/img-store/raw/master/20201224/1608817000638.png" alt="Zero trust principles in the proposed model"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>这篇论文是一个分享模型，只有被分享的人才可以看到文件。</p></blockquote><p>疑惑：如何实现多次分享，避免单个文件多次上传的做法！</p><p><a href="https://gitee.com/merlynr/img-store/blob/d1481813922e92a8e297194f2c8176aab822be66/resource/paper/%E8%87%B4%E5%8A%9B%E4%BA%8E%E5%BC%80%E5%8F%91%E5%9F%BA%E4%BA%8E%E9%9B%B6%E4%BF%A1%E4%BB%BB%E5%8E%9F%E5%88%99%E5%92%8C%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AE%89%E5%85%A8%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E5%85%B1%E4%BA%AB%E7%B3%BB%E7%BB%9F/ppt.pptx">详细内容见PPT</a></p>]]></content>
      
      
      <categories>
          
          <category> paper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> paper </tag>
            
            <tag> blokchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Block chain transaction privacy protection method and system</title>
      <link href="2020/11/10/Block%20chain%20transaction%20privacy%20protection%20method%20and%20system/"/>
      <url>2020/11/10/Block%20chain%20transaction%20privacy%20protection%20method%20and%20system/</url>
      
        <content type="html"><![CDATA[<p><a href="https://patents.google.com/patent/WO2019080933A1/zh">https://patents.google.com/patent/WO2019080933A1/zh</a></p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol><li>解决交易信息透明，造成隐私信息暴露</li><li>论文提出解决方案使用到了秘密共享方式，解决共谋问题</li><li>确保关键字安全性</li></ol><h4 id="预处理方法"><a href="#预处理方法" class="headerlink" title="预处理方法"></a>预处理方法</h4><ol><li>将层次属性加密与线性秘密共享相结合，提出了一种基于可搜索属性加密的区块链数据隐私保护控制方案，解决了传统区块链交易中的隐私暴露问题。</li><li>用户的访问控制由验证节点实现，避免了向区块链网络提交私钥和访问结构的安全风险。将私钥组件与区块链中用户节点的随机身份相关联可以解决共谋问题</li><li>授权用户可以通过可搜索的加密来快速搜索和监督交易信息。改进的算法确保了关键字的安全性。【算法应该看不懂】</li></ol><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ol><li><p>提出基于椭圆曲线加密算法m的更有效的盲签名混合方案—-该方案简单易用，通常适用于各种数字货币，【但它是集中式货币方案】。</p><blockquote><p>传统公钥密码体制（密钥长度一般为512bit）随着计算机运算速度的提升，已经有被破解的趋势了，同时RSA运算效率较低。利用曲线上的有理点组成的Abel群《TODO》及其上离散对数问题求解的困难性构成一些公钥密码体制，即密钥的每个bit都具有最高的安全强度，椭圆曲线密码体制中160bit长的密钥所展示的安全强度相当于RSA的1024bit</p></blockquote></li><li><p>使用盲签名之类《TODO》的混合加密技术—-区块链隐私保护机制【增加了技术成本，并且第三方实施令牌处理不可避免地增加了额外的服务开销】</p></li><li><p>提出了一种改进的基于环的秘密交易方案《TODO》</p><blockquote><p>在该方案中，大量的环签名被放置在可链接的自发匿名组签名的多层中，其解决方案可以保护身份隐私和交易隐私。尽管环签名提供了强大的匿名性，但它具有三个限制：产生交易数据较多，需要更多的记录的存储空间、签名的大小与参与者数量成正比，因此传统每个事务做了限制，每个事务有四个输出、隐藏的数量增加了检查的难度，即，它不仅验证交易期间是否生成了秘密加密货币，而且还确定了特定时刻的额外数量。</p></blockquote></li></ol><h3 id="初步知识"><a href="#初步知识" class="headerlink" title="初步知识"></a>初步知识</h3><h4 id="Bilinear-Mapping"><a href="#Bilinear-Mapping" class="headerlink" title="Bilinear Mapping"></a>Bilinear Mapping</h4><blockquote><p>双线性映射</p><blockquote><p>群</p><ol><li>封闭性——如果a和b都属于G，则a+b也属于G。</li><li>结合律——对于G中的任意元素a、b和c，都有（a+b）+c=a+（b+c）成立。</li><li>单位元——G中存在元素e，对于G中任意元素a，都有a+e=e+a=a成立。</li><li>逆元——对于G中任意元素a，G中都存在元素a’，使得a+a’=a’+a=e成立。G就叫作一个群，记为（G，+）</li><li>在群中定义求幂运算为重复使用群中的运算，如a^4 =a+a+a+a。规定a^0 =e为单位元。如果一个群的所有元素都是a的幂a^k，则称这个群是一个==循环群 #00BCD4==，这里的k是整数。a也被称为这个群的生成元。</li></ol></blockquote></blockquote><p><img src="https://gitee.com/merlynr/img-store/raw/master/20201223/1608734193371.png" alt="双线性映射"></p><p>设G1、G2都是阶为p的循环群，p是素数。如果映射e: G1 × G1 → G2 满足以下性质：</p><ol><li>双线性性。<br>对于任意a，b∈Z<sub>p</sub>和R，S∈G1，有e(R<sup>a</sup>, S<sup>b</sup>) = e(R, S)<sup>ab<sup>；</li><li>非退化性。<br>存在R，S∈G<sub>1</sub>，使得e(R, S) ≠ 1<sub>G2</sub>。这里1<sub>G2</sub>代表G2群的单位元；</li><li>可计算性。<br>存在有效的算法对任意的R，S∈G<sub>1</sub>，计算e(R, S)的值。<br>那么称<strong>e</strong>是一个<strong>双线性映射</strong>。</li></ol><h4 id="Determining-the-Bilinear-Diffie–"><a href="#Determining-the-Bilinear-Diffie–" class="headerlink" title="Determining the Bilinear Diffie–"></a>Determining the Bilinear Diffie–</h4><p>ellman Assumption (DBDH)</p><blockquote><p>确定双线性参数生产区的假设（DBDH）</p></blockquote><p>选择一个G1的生成器，设a,b,c,r属于（1，q-1）中任意质数，当g^a,g^b,g^c,g^r属于G1，e(g,g)<sup>abc</sup>和e(g,g)<sup>r</sup>属于G2,判断<strong>e(g,g)<sup>abc</sup>和e(g,g)<sup>r</sup>是否相等</strong></p><p><strong>判断条件：</strong><br>对于任意多项式概率时间算法的对手A，解决决策双线性Diffie-Hellman（DBDH）假设[i]的优势定义为</p><p><img src="https://gitee.com/merlynr/img-store/raw/master/20201223/1608734247064.png" alt="DBDH判断条件"></p><p>如果确定的值Adv<sup>DBDH</sup><sub> A</sub>可忽略不计，则将建立决策双线性Diffie-Hellman假设。</p><h4 id="Lsss-Linear-Secret-Sharing-Scheme"><a href="#Lsss-Linear-Secret-Sharing-Scheme" class="headerlink" title="Lsss Linear Secret Sharing Scheme"></a>Lsss Linear Secret Sharing Scheme</h4><blockquote><p>Lsss线性秘密共享方案【是对密钥的管理策略】</p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/95362628">有趣的栗子</a></p><p>在信息系统中使用的秘密共享，可以防止系统密钥的遗失、损坏和来自地方的攻击，减小秘密保存者的责任。在(t,n)秘密共享体制中，秘密分发者将一个秘密信息分成n个秘密份额，分发给n 个人，当需要恢复秘密信息时，任意少于t个的秘密保存者都得不到该秘密的任何信息。<br>现目前进行秘密共享的主流方案有基于访问控制树和秘密共享矩阵的。基于访问控制树进行秘密分享时，通过门限控制进行合理的多项式构造，最终将秘密分享给树的每一个子节点。</p><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><h4 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h4><blockquote><p>基于可搜索属性加密的区块链数据隐私访问控制系统模型如图</p></blockquote><p><img src="https://gitee.com/merlynr/img-store/raw/master/20201223/1608734364209.png" alt="基于可搜索属性加密的区块链数据隐私访问控制系统模型"></p><blockquote><p>包含的四个实体</p></blockquote><p><img src="https://gitee.com/merlynr/img-store/raw/master/20201223/1608734388573.png" alt="四个实体"></p><ol><li>数据所有者：首先进行初始化，生成索引密钥和陷门密钥，提取交易的关键词，然后使用索引密钥对索引进行加密，形成索引密文；其次，对陷门密钥进行加密以形成陷门密钥密文并共享数据。最后，使用安全签名算法对交易进行签名并加密，同时，数据所有者将索引关键字附加到交易密文的密文文件中。最重要的是，数据所有者可以是区块链上进行比特币交易的用户或矿工。</li><li>用户：注册系统生成与真实身份相对应的身份标识符RID和与用户属性相对应的私钥。另外，用户解密陷门密文并使用 用户密钥以生成陷门，然后发送区块链以请求交易密文。</li><li>验证节点：验证用户身份和权限的正确性，并在属性集合中计算用户的属性和私钥参数以及权限参数，以分发陷密钥密文，并将用户密钥UK分发给合法用户。</li><li>矿工节点：矿工节点在此期间广播所有交易信息，每个节点执行验证并在验证后加入区块链。计算并匹配数据所有者发送的陷门和索引，然后在匹配成功后将交易密文发送到数据使用方。</li></ol><h4 id="威胁模式"><a href="#威胁模式" class="headerlink" title="威胁模式"></a>威胁模式</h4><p><strong>前提：</strong> 只有“验证节点”是完全可信的，私钥能正常生成和分发给用户。大多数矿工节点半诚实【不破坏协议，根据规则可以推测用户信息】。此外，用户可能会合谋解密他们无法访问的数据。</p><h4 id="安全模型"><a href="#安全模型" class="headerlink" title="安全模型"></a>安全模型</h4><p><strong>安全模型是指对手与挑战者之间的博弈。</strong></p><ol><li>IND-CPA security model【Indistinguishability under chosen-plaintext attack】</li></ol><blockquote><p>选择明文攻击。可理解为攻击者拥有加密机的使用权限，可以加密自己想加密的任何明文。攻击目的：由明文和对应的密文来分析和推断加密算法的信息，主要是加密密钥。</p></blockquote><ul><li>初始化：挑战者A使用初始化算法生成公共参数和主密钥【重复使用的密钥，对称密钥】，并将主密钥发送给对手C。——<em>每次通信只使用一次的密钥称为会话密钥（session key）。相对于会话密钥，重复使用的密钥称为主密钥（master key）。</em></li><li>第一步：对手C重复尝试一组属性S1-Sq，但是没有属性满足访问</li><li>挑战：对手C选择两条消息M0; M1并将它们发送给挑战者A。挑战者A选择0或者1，和加密的访问结构的消息M，并将密文发送给对手C</li><li>第二步：</li></ul><ol><li>IND-CKA security model</li></ol><blockquote><p>关键字攻击</p></blockquote><h3 id="具体结构即功能实现"><a href="#具体结构即功能实现" class="headerlink" title="具体结构即功能实现"></a>具体结构即功能实现</h3><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>用户向系统提交注册申请，获取真实身份信息对应的身份RID和用户属性集，数据所有者（交易用户）进行注册获取密钥和身份标识。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><a href="https://blog.csdn.net/zhangwenjiezw886/article/details/51006774">双线性</a></p><ol><li>数据拥有者:：选择一个以质数为序的群G<sub>0</sub>,用元素g(单位元)生成群，在限制字段中选择N个元素(N为阶)，并使用系统属性形成系统属性集S，并根据属性之间的相关性来确定S中的属性。S被分为x个树，H<sub>i</sub>被设置为i个树的深度，H为树中最大深度；随机选择向量U=(U<sub>y</sub>)<sub>1=&lt;x=&lt;y</sub>和U’=(U’<sub>y’</sub>)<sub>1=&lt;x‘=&lt;y’</sub>，u<sub>y</sub>代表与y属性树相对应的public参数，数据所有者选择素数p的序列，并生成群G<sub>1</sub>,H<sub>1</sub>。数据拥有者选择两个随机数η(姨塔)，μ(谬)，然后计算生成公钥PK={g,g<sup>μ</sup>}和私钥SK=η代表陷门。</li><li>验证结点：Z<sup>*</sup><sub>p</sub>在有限域中用p-基元表达一组元素，从中选择两个大小不同的随机数α，β，验证结点通过计算PK={G<sub>0</sub>,g,g<sup>β</sup>,Y=e(g,g)<sup>α</sup>,U,U’}和MK={α，β}来定义一个双线性图e:G<sub>0</sub>xG<sub>0</sub>=G<sub>1</sub>。</li><li>交易生成和签名：交易用户A生成交易信息，通过钱包签名算法对自身身份进行加密，并使用钱包地址对应的私钥对其签名，然后发送给交易用户B。签名的算法如下()：</li></ol><p><img src="https://gitee.com/merlynr/img-store/raw/master/20201223/1608734446144.png" alt="签名算法"></p><blockquote><p>Trans:交易信息、<br>δ A为用户自身加密后的信息即用于标识、<br>CT<sub>A</sub>（Ciphertext密文）私钥加密产生签名</p></blockquote><ol><li>产生索引：交易者从交易明文信息中提取关键字，并用索引密钥g<sup>μ</sup>和两个随机数字进行加密。</li><li>加密：Encrypt(M，TK，PK)[信息，非对称传输密钥，公钥]</li></ol>]]></content>
      
      
      <categories>
          
          <category> paper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> paper </tag>
            
            <tag> block chain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习D一天</title>
      <link href="2020/11/10/%E5%AD%A6%E4%B9%A0D%E4%B8%80%E5%A4%A9/"/>
      <url>2020/11/10/%E5%AD%A6%E4%B9%A0D%E4%B8%80%E5%A4%A9/</url>
      
        <content type="html"><![CDATA[<h2 id="gt-Plane"><a href="#gt-Plane" class="headerlink" title="&gt; Plane"></a>&gt; Plane</h2><ul><li>[x] 提出信息安全理论项目初步计划</li><li>[x] 14:00-16:00 读身份加密的材料</li><li>[x] 16:10-17:20 完成医院系统项目日志集成<br><em>- [ ]  18:50-20:50 数据库的系统学习</em></li><li>[ ]  21:00-22:30 springmvc学习</li><li>[ ]  22:30-23:30 总结</li></ul><hr><h3 id="信息安全理论项目安排"><a href="#信息安全理论项目安排" class="headerlink" title="信息安全理论项目安排"></a>信息安全理论项目安排</h3><ol><li>李完成基本项目搭建及核心抓包功能实现</li><li>陈完成数据库表完成【先将需要的表构思一下发群里看一下】</li><li>邹完成规则及书写功能需求</li><li>郑和邹书写功能需求，及将规则写入后端</li><li>郑艺根据功能需求完成基本的框架搭建和样式</li></ol><h3 id="身份认证相关论文"><a href="#身份认证相关论文" class="headerlink" title="身份认证相关论文"></a>身份认证相关论文</h3><h4 id="A-Survey-of-Zero-Trust-Research"><a href="#A-Survey-of-Zero-Trust-Research" class="headerlink" title="A Survey of Zero Trust Research"></a>A Survey of Zero Trust Research</h4><p>@author 张宇 张妍【北京数字认证股份有限公司】</p><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ol><li>“边界防护”</li></ol><ol><li>何为无边界趋势下的网络安全问题</li><li></li><li>何为基于网络位置的隐式信任</li><li>何为静态防御</li><li>了解“ Google基于零信任构建的BeyondCorp项目”</li><li>了解“提出了软件定义边界（software defined perimeter,SDP)网络安全模型”</li><li>计算机专业词汇</li></ol><ul><li><strong>策略引擎（Policy Engine）：</strong> 该组件负责最终决定是否授予指定访问主体对资源（访问客体）的访问权限。策略引擎使用企业安全策略以及来自外部源（例如IP黑名单，威胁情报服务）的输入作为“信任算法”的输入，以决定授予或拒绝对该资源的访问，策略引擎的核心作用是信任评估。</li><li><strong>策略管理器（Policy Administrator）：</strong> 组件负责建立客户端与资源之间的连接。它将生成客户端用于访问企业资源的任何身份验证令牌或凭据。它与策略引擎紧密相关并依赖于其决定最终允许或拒绝连接，策略管理器的核心作用是策略判定点，是零信任动态权限的判定组件。</li><li><strong>策略执行点（Policy Enforcement Point）：</strong> 这实际上是一个组件系统，负责开始，持续监控、并最终结束访问主体与访问客体之间的连接。策略执行点实际可分为两个不同的组件：客户端组件（如用户笔记本电脑上的agent）与资源端组件（如资源前控制访问的网关），策略执行点的核心作用是确保业务的安全访问。</li><li><ul><li><strong>持续诊断和缓解计划系统（CDM System）：</strong> 该系统收集关于企业系统当前状态的信息，并将更新应用到配置和软件组件中。企业CDM系统还提供给策略引擎关于系统访问请求的信息。</li></ul></li><li><ul><li><strong>行业合规系统（Industry Compliance System）：</strong> 该系统确保企业与当前政府管理的一致性。包括企业开发的所有策略规则来确保合规。</li></ul></li><li><ul><li><strong>威胁情报流（Threat Intelligence）：</strong> 该系统提供帮助策略引擎进行访问决策的信息。</li></ul></li><li><ul><li><strong>数据访问策略（Data Access Policy）：</strong> 数据访问策略是企业为企业资源创建的关于数据访问的属性、规则和策略的集合。策略规则集可以编码在策略引擎中或有PE动态生成。</li></ul></li><li><ul><li><strong>企业公钥基础设施（PKI）：</strong> 该系统负责生成和记录企业对资源、应用等发布的证书。既包括全局CA生态系统和联邦PKI。</li></ul></li><li><ul><li><strong>ID管理系统（ID Management）：</strong> 系统负责创建、保存和管理企业用户帐户和身份记录。系统中既含有必要的用户信息，也含有其他企业特征，比如角色、访问属性、或分配的系统。</li></ul></li><li><ul><li><strong>安全应急和事件管理系统（SIEM System）：</strong> 集合了系统日志、网络流量、资源权利和其他信息的企业系统为企业信息系统体佛那个安全态势的反馈。</li></ul></li></ul><ol><li>何为分配基于二元决策的策略</li><li>了解RADIUS协议</li><li>了解SSO方式认证</li></ol><h5 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h5><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>如何进行动态认证？如何有效进行动态认证？</p><p><a href="https://www.secrss.com/articles/14045">引用</a><br><a href="chrome-extension://gfbliohnnapiefjpjlpjnehglfpaknnc/pages/pdf_viewer.html?r=https://www.gartner.com/teamsiteanalytics/servePDF?g=/imagesrv/media-products/pdf/Qi-An-Xin/Qianxin-1-1XXWAXWM.pdf">引用</a></p><h3 id="对于数据库的详细学习"><a href="#对于数据库的详细学习" class="headerlink" title="对于数据库的详细学习"></a>对于数据库的详细学习</h3>]]></content>
      
      
      
        <tags>
            
            <tag> Study </tag>
            
            <tag> Daily </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当前区块链交易的缺陷</title>
      <link href="2020/11/10/%E5%BD%93%E5%89%8D%E5%8C%BA%E5%9D%97%E9%93%BE%E4%BA%A4%E6%98%93%E7%9A%84%E7%BC%BA%E9%99%B7/"/>
      <url>2020/11/10/%E5%BD%93%E5%89%8D%E5%8C%BA%E5%9D%97%E9%93%BE%E4%BA%A4%E6%98%93%E7%9A%84%E7%BC%BA%E9%99%B7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>The first type: existing blockchain systems, such as the privacy protection technology used in Bitcoin and Ethereum, use “pseudo-anonymous” technology only for the nodes of the transaction, and the transaction party can create multiple addresses for transaction, each The address corresponds to a public key in the asymmetric encryption, and has no binding relationship with the true identity of the transaction party, that is, the address of the node is anonymous, and the transaction details are public and transparent, and the balance operation of the two transaction nodes is directly performed during the transaction. However, this method does not really guarantee that the node is “anonymous”. For example, in the transaction of the Bitcoin system, the user does not need to use the real name, but uses the public key hash value as the transaction identifier. However, by associating transaction information with personal information in real life, combined with address information and public account books of service providers, the address can correspond to individual users, and all their consumption records will be revealed, which will bring serious users private issues.</p></blockquote><ol><li>第一个现存的问题，现有系统只对交易过程进行“匿名”处理，但是交易内容和现实生活中的个人信息有所联系，例如比特币和以太坊通过为交易方提供多个地址，每个地址对应非对称加密过程中的一个公钥，即地址匿名，来保障用户匿名，只是对于交易内容进行操作。比特币交易系统中，也是类似，用户不需要真实信息，同时公钥哈希值作为交易标识。这样的交易内容是透明的，这样就存在一个问题，交易内容为透明的，同时避不开免的与现实生活有所关联，此时结合服务提供商等的地址及公共账本，地址即对应的个人用户，这样隐私就基本完全泄漏。—伪匿名，信息泄露风险</li></ol><blockquote><p>The second type: directly encrypts the balance on the public ledger. Only the node itself or the related party that gives the right can view the transaction information, and the other nodes cannot operate the data, and the book information is difficult to maintain consistency. For example, Chinaledger proposed a scheme based on the Central Counterparty (CCP). The transaction initiator uses the CCP’s public key to encrypt the transaction. After signing, it is submitted to the CCP. The CCP realizes decryption, checks the signature, checks the balance, and if it is valid, realizes the transfer of the transfer amount. . In this method, the remaining nodes can only endorse the transaction, but cannot endorse the balance. Although this scheme protects the privacy of the node user, it is too centralized, and the whole system relies on the reputation transaction of the CCP. There is also a State Channel-based privacy protection scheme proposed by the Ethereum community. In this transaction process, nodes in the blockchain submit transactions to smart contracts, and smart contracts implement encryption of intermediate process details. Not visible; when the transaction is completed, the final value allocation scheme is decrypted and returned to the rest of the blockchain. However, this method only protects the privacy of the intermediate process part, and the total transaction change is also transparent to all nodes.</p></blockquote><ol><li><p>通过对公共账本上的余额进行加密，只有节点本身或赋予权力的相关才能对交易信息可见，其余节点无法操作数据，账本信息难以保持一致性。例如Chinaledger提出了基于中央对手方(CCP)的方案，交易发起方使用CCP的公钥加密交易，签名后提交给CCP，由CCP实现解密、检验签名、检验余额，如果是有效再实现转账金额过户。此方法中，其余节点只能背书交易，而不能背书余额，此方案虽然保护了节点用户隐私，但过于中心化，整个系统依赖于CCP的信誉交易。还有以太坊社区提出的基于状态旁路(State channel)的隐私保护方案，此方案交易过程中，区块链中节点将交易提交到智能合约里,智能合约实现中间流程明细的加密，其余节点不可见;到交易完成时，再把最终价值分配方案解密，返回到区块链其余节点上。但此方法只保护了中间过程部分的隐私，交易的总额变动也是对所有节点透明的。—-过度依赖CCP，违背去中心化；以太网提出的基于状态旁路的隐私保护方案则是不在依赖CCP，但是最后结果依旧是透明的<br>.</p><blockquote><p>Third: Encryption methods such as additive homomorphic encryption or zero-knowledge proof are used to ensure privacy. Addition homomorphic encryption is an asymmetric encryption for numerical values. For encrypted values of A, B, and C, Enc(A), Enc(B), and Enc(C) are respectively characterized. If A+B= C, then Enc(A)+Enc(B)=Enc(C). For example, in the invention patent “CN106549749A”, “a blockchain privacy protection method based on additive homomorphic encryption”, the following scheme is disclosed: on a blockchain network, a transaction request node initiates a transaction, and The network node verifies that the transaction recipient receives the transaction amount and completes the transaction. The steps of the transaction encryption method are specifically: homomorphic key generation; splitting the sender’s account visible balance into transaction amount and remaining balance; using the entire network The public key encryption transaction amount and remaining balance are recorded as ciphertext X1 and X2; the transaction amount is encrypted by the recipient’s public key to obtain ciphertext Y1; the sender initiates the transaction, and the transaction content includes three fields of X1, X2 and Y1; The entire network node verifies the transaction information, maintains the public ledger, and updates the visible balance of the recipient. The above solution realizes the function of hiding the transaction amount and the user balance on the blockchain by using the additive homomorphic encryption technology, and hopes to solve the problem that the traditional blockchain transaction exposes the real transfer amount to realize the blockchain. Privacy protection. However, this solution cannot confirm the consistency of the transaction and lacks the verification link for the validity of the transaction. In addition, ZCash provides complete identity privacy protection and transaction content privacy protection based on Bitcoin using zero-knowledge proof technology. In the ZCash system, transactions have “zero knowledge”, neither exposing the addresses of both parties to the transaction, nor exposing the transaction amount. Since zero-knowledge proofs are complex cryptographic protocols, their introduction can significantly affect performance and lack the supervision of relevant authorities.</p></blockquote></li><li><p>第三:使用加法同态加密技术或者零知识证明等加密方法来保证隐私。加法同态加密技术虽然保障了交易的隐私保护功能，却无法保障交易一致性，同时无法保障交易的有效性；零知识证明则需要复杂的密码协议，这将大幅度影响性能，且确实相关权威的监管，同样失去交易的有效性，例如ZCash系统。</p></li></ol><p>Summary：<br>    提供隐私数据保护，对数据进行分布式确权和管理，满足对交易进行监管的功能【有效性】</p>]]></content>
      
      
      <categories>
          
          <category> paper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> graduate student </tag>
            
            <tag> paper </tag>
            
            <tag> block chain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-10-24【Daily】</title>
      <link href="2020/10/24/2020-10-24daily/"/>
      <url>2020/10/24/2020-10-24daily/</url>
      
        <content type="html"><![CDATA[<h3 id="毕设开题"><a href="#毕设开题" class="headerlink" title="毕设开题"></a>毕设开题</h3><ol><li>背景==》缩写、划点</li><li>国内外现状==》在自己相关研究方向上进行国内外分析【数据化】（有话题相关就进行分析）（没有话题就对技术进行分析）</li><li>目标==》进行详细阐述实现过程</li><li>开题即检验后期开发过程中的详细步骤是否合理可完成【需要详细阐述出来】</li><li>区分“研究方案”和“解决方案”</li></ol>]]></content>
      
      
      <categories>
          
          <category> daily report </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> report </tag>
            
            <tag> study </tag>
            
            <tag> summarize </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《囚徒》普希金</title>
      <link href="2020/10/19/lesslessqiu-tu-greatergreater-pu-xi-jin/"/>
      <url>2020/10/19/lesslessqiu-tu-greatergreater-pu-xi-jin/</url>
      
        <content type="html"><![CDATA[<p>我坐在阴湿牢狱的铁栏后<br>一只在禁锢中成长的鹰雏<br>和我郁郁地做伴；<br>它扑着翅膀，<br>在铁窗下啄食着血腥的食物。<br>它啄食着，丢弃着，又望望窗外，<br>像是和我感到同样的烦恼。<br>它用眼神和叫声向我招呼，<br>像要说：“我们飞去吧，是时候了，<br>“我们原是自由的鸟儿，飞去吧——<br>飞到那乌云后面明媚的山峦，<br>飞到那里，到那蓝色的海角，<br>只有风在欢舞……还有我做伴……</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2020-10-17【Daily】</title>
      <link href="2020/10/17/2020-10-17daily/"/>
      <url>2020/10/17/2020-10-17daily/</url>
      
        <content type="html"><![CDATA[<h2 id="EMMMMM，今天没学到东西，姿势不对，而且张柯师兄带妹儿在我旁边秀，太eeeeeeeeeeeeeeeex了"><a href="#EMMMMM，今天没学到东西，姿势不对，而且张柯师兄带妹儿在我旁边秀，太eeeeeeeeeeeeeeeex了" class="headerlink" title="EMMMMM，今天没学到东西，姿势不对，而且张柯师兄带妹儿在我旁边秀，太eeeeeeeeeeeeeeeex了"></a>EMMMMM，今天没学到东西，姿势不对，而且张柯师兄带妹儿在我旁边秀，太eeeeeeeeeeeeeeeex了</h2>]]></content>
      
      
      <categories>
          
          <category> daily report </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> report </tag>
            
            <tag> study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-10-15【Daily】</title>
      <link href="2020/10/15/2020-10-15daily/"/>
      <url>2020/10/15/2020-10-15daily/</url>
      
        <content type="html"><![CDATA[<h2 id="社会工程"><a href="#社会工程" class="headerlink" title="社会工程"></a>社会工程</h2><ul><li>emmmm,扣手机了，只看了几页的pdf</li><li>明天学下Google搜索的技巧</li><li>多关注容易忽视的信息查询窗口：校友录网站，支付宝，查询网，qq群，，，，，</li></ul><h2 id="数据库注入"><a href="#数据库注入" class="headerlink" title="数据库注入"></a>数据库注入</h2><ul><li>DVWA结合burpsuite的数据库注入操场预演练搞定了，后边可以快速发育了</li></ul><h2 id="springboot-ioc"><a href="#springboot-ioc" class="headerlink" title="springboot ioc"></a>springboot ioc</h2><ul><li>Bean的延长加载：spring会在项目启动的时候就初始化大量Bean，这就会导致项目启动慢，所有需要加入”default-lazy-init”属性，来减轻启动负担，可以通过延迟在关键的时候创建Bean来提高效率，<b>不过，spring启动时初始化Bean时可以检查是否存在配置错误，提早预警</b></li><li>＜context:component-scan/＞与＜context:annotation-config/＞，很多注解需要配置，而大部分通过xml配置进行注解驱动注册和包扫描功能。</li><li>IOC与依赖注入的区别：</li><li><ul><li>IOC:控制反转:将对象的创建权,由Spring管理.</li></ul></li><li><ul><li>DI(依赖注入):在Spring创建对象的过程中,把对象依赖的属性注入到类中。</li></ul></li></ul><h2 id="英语"><a href="#英语" class="headerlink" title="英语"></a>英语</h2><ul><li>我傻了，后天考试，发现这两天刷错题了🙂🙂🙂</li></ul>]]></content>
      
      
      <categories>
          
          <category> daily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> Java </tag>
            
            <tag> summarize </tag>
            
            <tag> front-end </tag>
            
            <tag> security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-10-14【Daily】</title>
      <link href="2020/10/14/2020-10-14daily/"/>
      <url>2020/10/14/2020-10-14daily/</url>
      
        <content type="html"><![CDATA[<h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h2><p><a href="https://blog.csdn.net/javazejian/article/details/54561302#bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F">Source</a></p><ol><li>Singleton作用域</li></ol><p>Bean的默认作用域，即每个bean在Spring整个容器中一直都是同一个，<b>一般用于过程操作流中的bean设置为Singleton</b></p><ol><li>prototype作用域</li></ol><p>每次获取Bean实例时都会新创建一个实例对象，对于需要避免数据污染的bean设置</p><ol><li>request与session作用域</li></ol><ul><li>对于每次HTTP请求到达应用程序，Spring容器会创建一个全新的Request作用域的bean实例，该bean实例仅在当前HTTP request内有效</li><li>每当创建一个新的HTTP Session时就会创建一个Session作用域的Bean，并该实例bean伴随着会话的存在而存在</li></ul><ol><li>globalSession作用域</li></ol><p>类似于Session作用域，相当于全局变量，类似Servlet的Application，适用基于portlet的web应用程序，请注意，portlet在这指的是分布式开发，而不是portlet语言开发。</p><p>【注】<b>请务必明确一点，默认情况下Spring容器在启动阶段就会创建bean，这个过程被称为预先bean初始化，这样是有好处的，可尽可能早发现配置错误，如配置文件的出现错别字或者某些bean还没有被定义却被注入等。当然如存在大量bean需要初始化，这可能引起spring容器启动缓慢，一些特定的bean可能只是某些场合需要而没必要在spring容器启动阶段就创建，这样的bean可能是Mybatis的SessionFactory或者Hibernate SessionFactory等，延迟加载它们会让Spring容器启动更轻松些，从而也减少没必要的内存消耗。</b></p>]]></content>
      
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-10-13【Daily】</title>
      <link href="2020/10/13/2020-10-13daily/"/>
      <url>2020/10/13/2020-10-13daily/</url>
      
        <content type="html"><![CDATA[<h2 id="社会工程"><a href="#社会工程" class="headerlink" title="社会工程"></a>社会工程</h2><ol><li>个人在网上需要另一套身份,吾即吾，吴非吾！-！</li><li>与陌生人聊天，一定要冷静，避免任何信息【任何，甚至爱好】走漏</li><li>可以通过一些快讯订阅来丰富自己的知识，例如：<a href="https://www.google.com/alerts">谷歌资讯</a></li><li>门户网站：国内个人信息泄露的源点。即通过筛选新浪，qq社区，网易，百度贴吧。。。。便可以查到一个人的生</li></ol><h2 id="Spring-Boot-IOC容器管理bean"><a href="#Spring-Boot-IOC容器管理bean" class="headerlink" title="Spring Boot IOC容器管理bean"></a>Spring Boot IOC容器管理bean</h2><p><a href="https://blog.csdn.net/javazejian/article/details/54561302#ioc%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86-bean">Bean的命名以及实例化方法</a></p><ol><li>Bean的命名</li></ol><ul><li>基于xml配置文件中的<bean/>存在属性id，name，其中一个bean在一个xml中的id只能唯一，但是它的name可以有多个，当对一个bean进行配置的时候可以通过别名来区别</li><li>基于Java注解的配置方式：使用org.springframework.stereotype.Service（@Service）和org.springframework.stereotype.Repository（@Repository）声明AccountServiceImpl和AccountDaoImpl类，使用@Autowired注解注入accountDao（需要在xml声明注解驱动）<b>有了注解声明，我们就不需要在xml中声明以上两个Bean,但是需要告诉Spring注解的Bean在那些包下，因此需要添加包扫描机制，此时需要启用Spring的context命名空间</b></li></ul><p><img src="http://Merlynr.github.io/post-images/1602599093551.png" alt=""></p><p><img src="http://Merlynr.github.io/post-images/1602599101037.png" alt=""></p><ol><li>Bean的实例化方法</li></ol><ul><li>Spring容器可以通过构造方法创建bean【通用】，然后可以在xml中注入</li></ul><p><img src="http://Merlynr.github.io/post-images/1602599339693.png" alt=""></p><ul><li>静态方法构造</li></ul><p><img src="http://Merlynr.github.io/post-images/1602599442231.png" alt=""></p><ul><li>实例工厂构造</li></ul><p><img src="http://Merlynr.github.io/post-images/1602599448947.png" alt=""></p><ol><li>Bean的重写机制</li></ol><ul><li>Bean的重写机制即：通过设置优先级有序的给同一个bean注入数值，这样就形成重写了</li></ul><ol><li>分层管理方式</li></ol><p><img src="http://Merlynr.github.io/post-images/1602599622741.png" alt=""></p><p><img src="http://Merlynr.github.io/post-images/1602599629963.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> daily report </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> report </tag>
            
            <tag> safety </tag>
            
            <tag> study </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-10-12【Daiily】</title>
      <link href="2020/10/12/2020-10-12daiily/"/>
      <url>2020/10/12/2020-10-12daiily/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot-IOC学习"><a href="#SpringBoot-IOC学习" class="headerlink" title="SpringBoot IOC学习"></a>SpringBoot IOC学习</h2><p>SpringBoot IOC架构利用反射技术通过配置文件的完全限定类名在运行时创建所需要的实现类，即在调用实体的时候不需要new，也不需要销毁新建的类了，因为Service没有和Dao进行关联，两者的耦合程度也降到最低了。<br><span id="more"></span><br><a href="https://blog.csdn.net/javazejian/article/details/54561302#spring-%E5%AE%B9%E5%99%A8%E8%A3%85%E9%85%8Dbeanxml%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F%E5%92%8C%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F">Source</a></p><h3 id="Spring容器装配BeanXML配置方式和注解配置方式"><a href="#Spring容器装配BeanXML配置方式和注解配置方式" class="headerlink" title="Spring容器装配BeanXML配置方式和注解配置方式"></a>Spring容器装配BeanXML配置方式和注解配置方式</h3><blockquote><p>装配方法：就是将dao和service的Bean保存到xml文件中，当使用时，在通过文件加载函数【ClassPathXmlApplicationContext，FileSystemXmlApplicationContext】来加载配置。</p><p>注解配置方式：这个比装配方法更简单，通过注释标明，然后通过声明加载函数【AnnotationConfigApplicationContext】来加载配置</p></blockquote><h3 id="Spring依赖注入"><a href="#Spring依赖注入" class="headerlink" title="Spring依赖注入"></a>Spring依赖注入</h3><p>所谓的依赖注入，其实是当一个bean实例引用到了另外一个bean实例时spring容器帮助我们创建依赖bean实例并注入（传递）到另一个bean中，如Service依赖于Dao，Spring容器会在创建Service的实现类和Dao的实现类后，把Dao的实现类注入Service实例中。</p><ol><li>Setter注入</li></ol><ul><li>被注入属性需要有set方法</li><li>通过配置文件中的<property> 来注入</li></ul><ol><li>构造函数注入</li></ol><ul><li>通过构造方法注入依赖，构造函数的参数一般情况下就是依赖项，spring容器会根据bean中指定的构造函数参数来决定调用那个构造函数</li><li>与Setter类似，这里使用<constructor-arg>来注入</li></ul><ol><li>循环依赖</li></ol><p><img src="http://Merlynr.github.io/post-images/1602511259264.png" alt=""></p><ul><li>互相注入，容易出现逻辑错误</li></ul><ol><li>自动装配与注解注入</li></ol><blockquote><p>基于xml的自动装配</p></blockquote><ul><li>基于xml配置，autowrie属性</li><li>包含三种模式：byTpye(根据类型)，byName(根据名称)、constructor(根据构造函数)</li><li><ul><li>在byTpye模式中，Spring容器会基于反射查看bean定义的类，然后找到与依赖类型相同的bean注入到另外的bean中，这个过程需要借助setter注入来完成，因此必须存在set方法，否则注入失败。</li></ul></li><li><ul><li>事实上byType模式可能存一种注入失败的情况，由于是基于类型的注入，因此当xml文件中存在多个相同类型名称不同的实例Bean时，Spring容器依赖注入仍然会失败,<b>可以通过＜bean＞标签的autowire-candidate设置为false来过滤那些不需要注入的实例Bean</b></li></ul></li></ul><blockquote><p>基于注解的自动装配(@Autowired&amp;@Resource&amp;@Value)</p></blockquote><ul><li>通过 @Autowired的使用标注到成员变量时不需要有set方法</li><li>@Autowired 默认按类型匹配的</li><li>使用注解时必须启动注解驱动 <context:annotation-config /></li><li>与@Autowried具备相同功效的还有@Resource，默认按 byName模式 自动注入</li><li>@Resource有两个中重要的属性：name和type</li></ul><blockquote><p>基于@Value注解的自动装配以及properties文件读取</p></blockquote><p><img src="http://Merlynr.github.io/post-images/1602512057020.png" alt="注释使用"></p><p><img src="http://Merlynr.github.io/post-images/1602512073526.png" alt="xml配置"></p>]]></content>
      
      
      <categories>
          
          <category> daily report </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> report </tag>
            
            <tag> study </tag>
            
            <tag> Java </tag>
            
            <tag> summarize </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-10-09【Daily】</title>
      <link href="2020/10/09/2020-10-09/"/>
      <url>2020/10/09/2020-10-09/</url>
      
        <content type="html"><![CDATA[<h2 id="《SQL注入攻击与防御》P1-P36"><a href="#《SQL注入攻击与防御》P1-P36" class="headerlink" title="《SQL注入攻击与防御》P1-P36"></a>《SQL注入攻击与防御》P1-P36</h2><h3 id="理解出现数据库安全威胁的原因"><a href="#理解出现数据库安全威胁的原因" class="headerlink" title="理解出现数据库安全威胁的原因"></a>理解出现数据库安全威胁的原因</h3><blockquote><p>我认为出现安全威胁的原因主要是两部分原因，一部分是由互联网公司对于配置和使用数据的不重视导致，尤其是广泛的中小企业后端开发和数据库配置都有后端开发程序员来掌控，而由于技术专精，后端程序员的更多能力体现在对于数据库的使用，而数据库中对于库甚至表的权限却没有能力管理；第二部分就是导致数据库注入攻击事件频发的原因，数据库与开发框架的混合使用，对于传入参数无法进行精确及时的判断，导致数据库无法判断传入的是参数还是指令。</p></blockquote><h2 id="《社工档案袋》P1-P20"><a href="#《社工档案袋》P1-P20" class="headerlink" title="《社工档案袋》P1-P20"></a>《社工档案袋》P1-P20</h2><blockquote><p>重新理解信息安全攻击，开阔眼界，消除对于网络安全的狭义理解。网络安全不仅仅应该局限于网络上的信息收集，还要将这种安全攻击策略用于真实社会上进行尝试，及广义上的社会工程学。</p></blockquote><h2 id="spring的学习"><a href="#spring的学习" class="headerlink" title="spring的学习"></a>spring的学习</h2><ol><li><a href="https://blog.csdn.net/javazejian/article/details/54561302gh">spring的ioc原理</a></li><li><a href="https://www.cnblogs.com/leoo2sk/archive/2008/04/10/1146447.html#">面向对象和面向接口</a></li><li>反射的编程技术<ul><li>我理解就是ioc的技术支持</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> daily report </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> graduate student </tag>
            
            <tag> report </tag>
            
            <tag> safety </tag>
            
            <tag> study </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加密通信的演化</title>
      <link href="2020/09/15/jia-mi-tong-xin-de-yan-hua/"/>
      <url>2020/09/15/jia-mi-tong-xin-de-yan-hua/</url>
      
        <content type="html"><![CDATA[<p>私密和公密都可以进行加密解密，但是加密与解密对应的关系，必须是一方加密另一方解密</p><p>RSA<br>1.安全漏洞：黑客可以通过传输简单字符给服务器，服务器又把用私密加密的报文传给客户端，黑客就可以较为容易的破解出私密<br>避免方法：服务端进行加密之前先将客户端传来的信息包进行hash计算，然后对hash☞进行加密。<br>2.安全威胁：在通信过程中，黑客将获取到的数据包反复发送给服务器，严重占用资源。<br>解决方法：通过加入标识【序号或随机数】，服务端发现这个报文是被反复发送的则立即中断网络通信。<br>存在问题：如果这种反复提交情况一直持续，则会造成网络通信持续中断<br>3.安全威胁：:黑客可以修改通信中的密文，从而影响客户端与服务端的正常通信<br>解决方法：在传输之前将要传输的内容进行一次hash计算，然后将传输内容和hash值一起传输给接收方，接收方接收后将拿到的内容进行hash计算，然后比对hash值，如果一样说没就没有被修改过，否则立马中止通信，并进行安全维护</p><p>2020-9.16 4. 在windows中对数字证书进行管理</p>]]></content>
      
      
      <categories>
          
          <category> security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> summarize </tag>
            
            <tag> security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详记HTTP向HTTPS进化</title>
      <link href="2020/06/19/xiang-ji-http-yu-https-zhi-jian-de-qu-bie/"/>
      <url>2020/06/19/xiang-ji-http-yu-https-zhi-jian-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p>[] <del>加强对于网络通信的理解</del><br>[]HTTP和HTTPS的运行原理<br>[]通信套接字的重新学习<br>[]SSL的工作原理</p><h1 id="两者表面的区别"><a href="#两者表面的区别" class="headerlink" title="两者表面的区别"></a>两者表面的区别</h1><ol><li>HTTP（Hypertext Transfer Protocol）是超文本传输协议，<font color=#DE6B6E>信息是明文</font>，HTTPSHypertext Transfer Protocol Secure则是既有安全性的SSL加密传输协议。基本可以理解为在HTTP的传输基础上加入SSL层来加密信息。两者请求和响应都是已相同的方式进行工作。</li><li>HTTP采用80端口连接，HTTPS采用443端口连接qi</li><li>HTTP与HTTPS<font color=#FAE05C>连接方式不同</font></li><li>HTTPS在连接中需要CA证书认证身份，一般需要money购买</li><li>HTTP连接是<font color=#DE6B6E>无状态的</font>，可以短连接也可以长连接，更加灵活；HTTPS协议是由<font color=#DE6B6E>SSL+HTTP协议</font>构建的可加密传输，身份认证的网络协议，虽然建立连接变得复杂但是更加安全，需要多次握手，所以一般会加剧50%时间延迟，且会消耗 CPU 资源，对服务器资源消耗较大</li></ol><h1 id="HTTP和HTTPS建立连接方式"><a href="#HTTP和HTTPS建立连接方式" class="headerlink" title="HTTP和HTTPS建立连接方式"></a>HTTP和HTTPS建立连接方式</h1><h2 id="HTTP建立连接"><a href="#HTTP建立连接" class="headerlink" title="HTTP建立连接"></a>HTTP建立连接</h2><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p><img src="https://Merlynr.github.io/post-images/1592550376754.png" alt=""></p><p>==TCP三次握手(Three-way Handshake)==<br>TCP/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。“即互联网中TCP/IP就可以满足信息通信，但是想要识别传输的信息是否有意义，我们就需要应用层协议”</p><blockquote><p>  TCP提供的可靠数据传输服务，是依靠接收端TCP软件按序号对收到的数据分组进行逐一确认实现的。这个过程在TCP收发端开始通信时，被称为三次握手初始化。<br>     三次握手的目的是使收发端的数据发送和接收同步，协调可以收发的数据量，建立虚连接。双方的TCP协议软件在交换数据时必须首先建立会话连接，然后才能够以数据分组为单位进行通信。接收端TCP协议软件每收到一个数据分组，在检验传输无误后，就对发送端计算机发送确认信息(ACK，Acknowledgement)，通知该序号分组收到。<br>     数据传输过程中，发送端对已经发出的分组要有记录，并且设置等待确认的计时器，对超过规定时间未收到确认的分组按照丢失重传处理；接收端的TCP协议软件会自动检查是否所有的数据分组都已收到，如果发现哪个数据分组损坏，接收端会将它舍弃，并通知发送端重传；接收端的TCP协议软件还能对未按顺序到达的数据分组进行重新排序，解决乱序问题。<br>     收发端TCP协议软件进行带确认的数据传送过程如所示。在图中，发送端将序号为100的数据分组(SEQ=100)送出；接收端收到后，向发送端回应一个序号为200的分组(SEQ=200)，内容是对收到序号为100的数据分组的确认，确认信息是对收到的数据分组序号加1(ACK=101)；发送端得知序号100的分组收到后，发送下一个数据分组(序号为101， SEQ=101)，并且在该分组中带有对收到序号为200的回应分组的确认(仍然是对收到的分组序号加1，ACK=201)。<br>     最后，当接收端计算机的TCP协议软件确认收到的数据分组无误，就根据封装在分组头部的目的端口号，识别出目的应用程序，将分组中的数据取出并按照原来顺序组合好交付给相应程序。</p><blockquote><p><a href="https://blog.csdn.net/wwj_748/article/details/11855289">FROM:TCP协议的作用？-IT_xiao小巫</a> </p></blockquote></blockquote><ul><li>初始状态：A，B都属于初始状态都是关闭状态</li><li>状态变化：A主动打开连接，B被动打开连接并进入监听状态</li><li>第一次握手：A向B发送一个TCP包，其中包中SYN标志设置为1，表明A向B请求建立连接，并设置序号seq=x，其中x的值表示第一个数据字节序号为x（x不确定，即seq是个随机值）。<font color=#DE6B6E>注意：</font>SYN包就是SYN标设为1的TCP包，只有A收到B发来的SYN包，才可以建立连接，否则无法建立连接。因此，<font color=#FAE05C>如果你的防火墙丢弃所有的发往外网接口的SYN包，那么你将不能让外部任何主机主动建立连接。</font></li><li>状态变化：A进入SYN_SEND状态，等待B的确认</li><li>第二次握手：B如果同意建立连接，会向A发送一个对A发送的SYN包的确认（SYN/ACK）包， 确认号ack=x+1，初始序号seq=y（随机值）<br><font color=#DE6B6E>注意：</font>SYN/ACK包是仅SYN 和 ACK 标记为1的包。这个报文也不能携带数据，但是同样要消耗一个序号。</li><li>状态变化：B进入SYN-RCVD状态（同步收到）</li><li>第三次握手：A收到B的确认TCP报后，向B发送一个确认收到B发送的确认报，其中确认报确认报文段（ACK=1，确认号ack=y+1，序号seq=x+1）</li><li>状态变化：A接到B的确认报文进行检查后变为ESTABLISHED（已建立连接）</li><li>状态变化：当B收到A的确认报文进行检查后变为ESTABLISHED（已建立连接）<br><font color=#DE6B6E>注意：</font>A收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并且此时操作系统为该TCP连接分配TCP缓存和变量，并将该数据包发送给B，B检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功。</li></ul><blockquote><blockquote><p><a href="https://blog.csdn.net/xingerr/article/details/72834303">FROM：TCP三次握手详解-Shirsen</a><br><a href="https://juejin.im/post/5b1d34eb6fb9a01e7d5c3e25">FROM：注意！是TCP不是HTTP的3次握手与4次挥手-鲍康霖</a></p></blockquote><p>三次握手的目的是连接服务器指定端口，建立 TCP连接，并同步连接双方的序列号和确认号，交换 TCP窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。</p></blockquote><h3 id="HTTPS通信中存在问题"><a href="#HTTPS通信中存在问题" class="headerlink" title="HTTPS通信中存在问题"></a>HTTPS通信中存在问题</h3><ol><li>容易被监听<br>http通信都是明文，数据在客户端与服务器通信过程中，任何一点都可能被劫持。比如，发送了银行卡号和密码，hacker劫取到数据，就能看到卡号和密码，这是很危险的</li><li>被伪装<br>http通信时，无法保证通行双方是合法的，通信方可能是伪装的。比如你请求www.taobao.com,你怎么知道返回的数据就是来自淘宝，中间人可能返回数据伪装成淘宝。</li><li>被篡改<br>hacker中间篡改数据后，接收方并不知道数据已经被更改</li></ol><h2 id="HTTPS连接方式"><a href="#HTTPS连接方式" class="headerlink" title="HTTPS连接方式"></a>HTTPS连接方式</h2><p>==https是http与ssl的结合体==</p><p><img src="https://Merlynr.github.io/post-images/1592735988318.png" alt=""></p><h3>客户端与服务器获取验证的通信过程</h3><ul><li>客户端发送请求到服务器端</li><li>服务器端返回证书和公开密钥，公开密钥作为证书的一部分而存在</li><li>客户端验证证书和公开密钥的有效性，如果有效，则生成共享密钥并使用公开密钥加密发送到服务器端</li><li>服务器端使用私有密钥解密数据，并使用收到的共享密钥加密数据，发送到客户端</li><li>客户端使用共享密钥解密数据</li><li>SSL加密建立………</li></ul>]]></content>
      
      
      <categories>
          
          <category> daily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> daily </tag>
            
            <tag> Java </tag>
            
            <tag> summarize </tag>
            
            <tag> front-end </tag>
            
            <tag> security </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
